<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AION MARS - Gateway Framework Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', monospace;
            background: linear-gradient(180deg, #050508 0%, #0a0812 50%, #080510 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 6px;
            gap: 6px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background: rgba(15, 10, 20, 0.95);
            border-radius: 5px;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .header h1 {
            font-size: 0.9rem;
            background: linear-gradient(90deg, #8b5cf6, #ec4899, #f97316);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-stats {
            display: flex;
            gap: 10px;
            font-size: 0.5rem;
        }

        .header-stats .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2px 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
        }

        .header-stats .val { font-size: 0.65rem; font-weight: bold; }
        .header-stats .val.high { color: #4ade80; }
        .header-stats .val.mid { color: #fbbf24; }
        .header-stats .val.low { color: #ef4444; }
        .header-stats .label { color: #555; font-size: 0.32rem; text-transform: uppercase; }

        .pulse-indicator {
            display: none;
            background: rgba(34, 211, 238, 0.3);
            border: 1px solid #22d3ee;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.5rem;
            color: #22d3ee;
            animation: pulse-glow 0.5s ease-out;
        }

        .pulse-indicator.active { display: block; }
        .pulse-indicator.local { background: rgba(249, 115, 22, 0.3); border-color: #f97316; color: #f97316; }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 20px rgba(34, 211, 238, 0.8); }
            100% { box-shadow: 0 0 0 rgba(34, 211, 238, 0); }
        }

        .main-layout {
            display: grid;
            grid-template-columns: 210px 1fr 220px;
            gap: 6px;
            flex: 1;
            overflow: hidden;
        }

        .panel {
            background: rgba(15, 10, 20, 0.95);
            border: 1px solid rgba(139, 92, 246, 0.15);
            border-radius: 5px;
            padding: 6px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            font-size: 0.45rem;
            color: #8b5cf6;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            padding-bottom: 3px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.15);
        }

        .map-container {
            position: relative;
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
        }

        canvas { width: 100%; height: 100%; display: block; }

        .control-item {
            margin-bottom: 4px;
        }

        .control-item label {
            display: block;
            font-size: 0.38rem;
            color: #666;
            margin-bottom: 1px;
        }

        .control-item select, .control-item input[type="number"] {
            width: 100%;
            padding: 2px 4px;
            background: #0a0510;
            color: white;
            border: 1px solid #333;
            border-radius: 2px;
            font-size: 0.48rem;
        }

        input[type="range"] {
            width: 100%;
            accent-color: #8b5cf6;
            height: 2px;
        }

        .btn {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.4);
            color: #8b5cf6;
            padding: 3px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.42rem;
            transition: all 0.2s;
            width: 100%;
            margin-top: 2px;
        }

        .btn:hover { background: rgba(139, 92, 246, 0.2); }
        .btn.active { background: #4ade80; color: #050510; border-color: #4ade80; }
        .btn.danger { background: rgba(239, 68, 68, 0.1); border-color: #ef4444; color: #ef4444; }
        .btn.pulse { background: rgba(34, 211, 238, 0.1); border-color: #22d3ee; color: #22d3ee; }
        .btn.export { background: rgba(34, 211, 238, 0.1); border-color: #22d3ee; color: #22d3ee; }
        .btn.octopus { background: rgba(249, 115, 22, 0.1); border-color: #f97316; color: #f97316; }
        .btn.siphonophore { background: rgba(168, 85, 247, 0.1); border-color: #a855f7; color: #a855f7; }
        .btn-row { display: flex; gap: 2px; }
        .btn-row .btn { flex: 1; }

        .metric-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            padding: 4px;
            margin-bottom: 4px;
        }

        .metric-section h4 {
            font-size: 0.38rem;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .metric-section h4.fault { color: #ef4444; }
        .metric-section h4.cascade { color: #f97316; }
        .metric-section h4.component { color: #22d3ee; }
        .metric-section h4.pulse { color: #a78bfa; }
        .metric-section h4.arm { color: #f97316; }
        .metric-section h4.skin { color: #ec4899; }
        .metric-section h4.zooid { color: #a855f7; }

        .metric-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.36rem;
            padding: 1px 0;
        }

        .metric-row .label { color: #555; }
        .metric-row .val { color: #8b5cf6; font-family: monospace; }
        .metric-row .val.good { color: #4ade80; }
        .metric-row .val.warn { color: #fbbf24; }
        .metric-row .val.bad { color: #ef4444; }

        .giant-component-display {
            text-align: center;
            padding: 4px;
            background: rgba(34, 211, 238, 0.1);
            border: 1px solid rgba(34, 211, 238, 0.3);
            border-radius: 3px;
            margin: 3px 0;
        }

        .giant-component-display .value {
            font-size: 0.9rem;
            font-weight: bold;
            color: #22d3ee;
            font-family: monospace;
        }

        .giant-component-display .label {
            font-size: 0.32rem;
            color: #888;
        }

        .component-bar {
            height: 8px;
            background: #0a0510;
            border-radius: 4px;
            overflow: hidden;
            margin: 3px 0;
            display: flex;
        }

        .component-bar .segment {
            height: 100%;
            transition: width 0.3s;
        }

        .arm-bar {
            height: 12px;
            background: #0a0510;
            border-radius: 4px;
            overflow: hidden;
            margin: 3px 0;
            display: flex;
            gap: 1px;
        }

        .arm-bar .segment {
            height: 100%;
            transition: width 0.3s;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.28rem;
            color: rgba(255,255,255,0.8);
        }

        .fault-list {
            font-size: 0.35rem;
            max-height: 50px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 2px;
            padding: 3px;
        }

        .fault-item {
            display: flex;
            justify-content: space-between;
            padding: 1px 0;
            border-bottom: 1px solid rgba(255,255,255,0.03);
        }

        .fault-item .id { color: #ef4444; }
        .fault-item .cycle { color: #555; }

        .cascade-meter {
            height: 6px;
            background: #0a0510;
            border-radius: 3px;
            overflow: hidden;
            margin: 3px 0;
        }

        .cascade-meter .fill {
            height: 100%;
            background: linear-gradient(90deg, #f97316, #ef4444);
            transition: width 0.3s;
        }

        .chart-container {
            height: 55px;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
            margin: 3px 0;
            position: relative;
        }

        .overlay {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0,0,0,0.85);
            padding: 3px 5px;
            border-radius: 3px;
            font-size: 0.36rem;
            pointer-events: none;
        }

        .component-indicator {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0,0,0,0.85);
            border: 1px solid rgba(34, 211, 238, 0.5);
            padding: 4px 8px;
            border-radius: 3px;
            text-align: center;
        }

        .component-indicator .val {
            font-size: 0.75rem;
            font-weight: bold;
            color: #22d3ee;
        }

        .component-indicator .label {
            font-size: 0.28rem;
            color: #888;
        }

        .pulse-ring {
            position: absolute;
            border: 2px solid rgba(34, 211, 238, 0.6);
            border-radius: 50%;
            pointer-events: none;
            animation: ring-expand 1s ease-out forwards;
        }

        .pulse-ring.local {
            border-color: rgba(249, 115, 22, 0.6);
        }

        @keyframes ring-expand {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }

        .dust-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(ellipse at center,
                rgba(180, 120, 60, 0) 0%,
                rgba(180, 120, 60, var(--dust-opacity, 0)) 100%);
            pointer-events: none;
        }

        .bloom-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at center,
                rgba(236, 72, 153, 0.15) 0%,
                rgba(236, 72, 153, 0.08) 30%,
                rgba(236, 72, 153, 0) 60%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            animation: bloom-pulse 2s ease-in-out infinite;
        }

        .bloom-overlay.active {
            opacity: 1;
        }

        @keyframes bloom-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .bloom-indicator {
            position: absolute;
            top: 35px;
            right: 4px;
            background: rgba(236, 72, 153, 0.9);
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.4rem;
            font-weight: bold;
            display: none;
            animation: bloom-blink 1s ease-in-out infinite;
        }

        .bloom-indicator.active {
            display: block;
        }

        @keyframes bloom-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .legend {
            position: absolute;
            bottom: 4px;
            left: 4px;
            background: rgba(0,0,0,0.85);
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 0.28rem;
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            max-width: 280px;
        }

        .legend-item { display: flex; align-items: center; gap: 2px; }
        .legend-dot { width: 4px; height: 4px; border-radius: 50%; }

        .log {
            flex: 1;
            overflow-y: auto;
            font-size: 0.33rem;
            font-family: monospace;
            padding: 3px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
            max-height: 60px;
        }

        .log-entry { margin-bottom: 1px; }
        .log-entry.fault { color: #ef4444; }
        .log-entry.pulse { color: #22d3ee; }
        .log-entry.cascade { color: #f97316; }
        .log-entry.component { color: #a78bfa; }
        .log-entry.arm { color: #f97316; }
        .log-entry.skin { color: #ec4899; }
        .log-entry.zooid { color: #a855f7; }
        .log-entry.wave { color: #06b6d4; }
        .log-entry.heal { color: #4ade80; }

        .toggle-row {
            display: flex;
            gap: 3px;
            margin-bottom: 3px;
        }

        .toggle-btn {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border: 1px solid #333;
            color: #666;
            padding: 2px 3px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.35rem;
            transition: all 0.2s;
        }

        .toggle-btn.active {
            background: rgba(139, 92, 246, 0.2);
            border-color: #8b5cf6;
            color: #8b5cf6;
        }

        .zooid-legend {
            display: flex;
            gap: 4px;
            font-size: 0.32rem;
            margin-top: 3px;
        }

        .zooid-legend span {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .wave-indicator {
            position: absolute;
            bottom: 4px;
            right: 4px;
            background: rgba(0,0,0,0.85);
            border: 1px solid rgba(6, 182, 212, 0.5);
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 0.32rem;
            color: #06b6d4;
        }

        .skin-wave {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            animation: skin-wave-expand 0.8s ease-out forwards;
        }

        @keyframes skin-wave-expand {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(2.5); opacity: 0; }
        }

        .metachronal-trail {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            pointer-events: none;
            animation: trail-fade 0.5s ease-out forwards;
        }

        @keyframes trail-fade {
            0% { opacity: 0.6; }
            100% { opacity: 0; }
        }

        /* Trit System Styles */
        .trit-section {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .metric-section h4.trit { color: #3b82f6; }

        .trit-distribution {
            display: flex;
            gap: 3px;
            margin: 4px 0;
        }

        .trit-box {
            flex: 1;
            text-align: center;
            padding: 4px 2px;
            border-radius: 3px;
            font-size: 0.4rem;
        }

        .trit-box.pos {
            background: rgba(74, 222, 128, 0.2);
            border: 1px solid #4ade80;
            color: #4ade80;
        }

        .trit-box.zero {
            background: rgba(156, 163, 175, 0.2);
            border: 1px solid #9ca3af;
            color: #9ca3af;
        }

        .trit-box.neg {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #ef4444;
        }

        .trit-box .count {
            font-size: 0.55rem;
            font-weight: bold;
            display: block;
        }

        .consensus-indicator {
            position: absolute;
            top: 65px;
            right: 4px;
            background: rgba(0,0,0,0.85);
            border: 1px solid rgba(59, 130, 246, 0.5);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.4rem;
            text-align: center;
            display: none;
        }

        .consensus-indicator.active { display: block; }
        .consensus-indicator .val { font-size: 0.6rem; font-weight: bold; }
        .consensus-indicator .val.pos { color: #4ade80; }
        .consensus-indicator .val.zero { color: #9ca3af; }
        .consensus-indicator .val.neg { color: #ef4444; }

        .btn.trit { background: rgba(59, 130, 246, 0.1); border-color: #3b82f6; color: #3b82f6; }
        .btn.trit-pos { background: rgba(74, 222, 128, 0.1); border-color: #4ade80; color: #4ade80; }
        .btn.trit-zero { background: rgba(156, 163, 175, 0.1); border-color: #9ca3af; color: #9ca3af; }
        .btn.trit-neg { background: rgba(239, 68, 68, 0.1); border-color: #ef4444; color: #ef4444; }

        .log-entry.trit { color: #3b82f6; }

        .trit-wave-indicator {
            position: absolute;
            bottom: 25px;
            right: 4px;
            background: rgba(0,0,0,0.85);
            border: 1px solid rgba(59, 130, 246, 0.5);
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 0.32rem;
            color: #3b82f6;
            display: none;
        }

        .trit-wave-indicator.active { display: block; }

        .entropy-bar {
            height: 6px;
            background: #0a0510;
            border-radius: 3px;
            overflow: hidden;
            margin: 3px 0;
        }

        .entropy-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s;
        }

        /* Adaptive Noise Styles */
        .noise-section {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .metric-section h4.noise { color: #fbbf24; }

        .noise-bar {
            height: 8px;
            background: #0a0510;
            border-radius: 4px;
            overflow: hidden;
            margin: 3px 0;
            position: relative;
        }

        .noise-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #fbbf24, #ef4444);
            transition: width 0.3s;
        }

        .noise-bar .marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: white;
        }

        .noise-indicator {
            position: absolute;
            top: 95px;
            right: 4px;
            background: rgba(0,0,0,0.85);
            border: 1px solid rgba(251, 191, 36, 0.5);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.4rem;
            text-align: center;
            display: none;
        }

        .noise-indicator.active { display: block; }
        .noise-indicator .val { font-size: 0.55rem; font-weight: bold; color: #fbbf24; }

        /* Live Analysis Dashboard */
        .dashboard-toggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(139, 92, 246, 0.9);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.5rem;
            font-weight: bold;
        }

        .dashboard-toggle:hover { background: rgba(139, 92, 246, 1); }

        .dashboard-panel {
            position: fixed;
            bottom: 50px;
            right: 10px;
            width: 420px;
            max-height: 70vh;
            background: rgba(10, 5, 15, 0.97);
            border: 1px solid rgba(139, 92, 246, 0.4);
            border-radius: 8px;
            padding: 10px;
            z-index: 999;
            display: none;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .dashboard-panel.active { display: block; }

        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
        }

        .dashboard-header h3 {
            font-size: 0.6rem;
            color: #a78bfa;
            margin: 0;
        }

        .dashboard-header .cycle {
            font-size: 0.5rem;
            color: #666;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        .dashboard-card {
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 5px;
            padding: 6px;
        }

        .dashboard-card h4 {
            font-size: 0.4rem;
            color: #888;
            margin: 0 0 4px 0;
            text-transform: uppercase;
        }

        .dashboard-card .value {
            font-size: 0.7rem;
            font-weight: bold;
            font-family: monospace;
        }

        .dashboard-card .trend {
            font-size: 0.4rem;
            margin-left: 4px;
        }

        .trend.up { color: #4ade80; }
        .trend.down { color: #ef4444; }
        .trend.stable { color: #666; }

        .mini-chart {
            height: 40px;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
            margin-top: 4px;
            position: relative;
            overflow: hidden;
        }

        .mini-chart canvas {
            width: 100%;
            height: 100%;
        }

        .correlation-matrix {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2px;
            font-size: 0.32rem;
            margin-top: 6px;
        }

        .corr-cell {
            padding: 3px;
            text-align: center;
            border-radius: 2px;
        }

        .corr-cell.header {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
            font-weight: bold;
        }

        .corr-cell.pos { background: rgba(74, 222, 128, 0.3); color: #4ade80; }
        .corr-cell.neg { background: rgba(239, 68, 68, 0.3); color: #ef4444; }
        .corr-cell.neutral { background: rgba(100, 100, 100, 0.2); color: #888; }

        .event-log {
            max-height: 80px;
            overflow-y: auto;
            font-size: 0.35rem;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
            padding: 4px;
            margin-top: 6px;
        }

        .event-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .event-item .type { font-weight: bold; }
        .event-item .type.critical { color: #ef4444; }
        .event-item .type.warning { color: #fbbf24; }
        .event-item .type.info { color: #22d3ee; }
        .event-item .type.success { color: #4ade80; }

        .phase-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px;
            background: rgba(0,0,0,0.4);
            border-radius: 5px;
            margin-top: 6px;
        }

        .phase-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: phase-pulse 1.5s ease-in-out infinite;
        }

        .phase-dot.stable { background: #4ade80; }
        .phase-dot.transition { background: #fbbf24; }
        .phase-dot.critical { background: #ef4444; }

        @keyframes phase-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.9); }
        }

        .phase-label {
            font-size: 0.45rem;
            font-weight: bold;
        }

        .phase-label.stable { color: #4ade80; }
        .phase-label.transition { color: #fbbf24; }
        .phase-label.critical { color: #ef4444; }

        .stats-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.38rem;
            padding: 2px 0;
        }

        .stats-row .label { color: #666; }
        .stats-row .val { color: #a78bfa; font-family: monospace; }

        /* Liminal Mode Styles */
        .liminal-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(ellipse at center,
                rgba(139, 92, 246, 0.1) 0%,
                rgba(139, 92, 246, 0.05) 50%,
                rgba(139, 92, 246, 0) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            animation: liminal-pulse 1.5s ease-in-out infinite;
        }

        .liminal-overlay.active { opacity: 1; }

        @keyframes liminal-pulse {
            0%, 100% { transform: scale(1); filter: hue-rotate(0deg); }
            50% { transform: scale(1.02); filter: hue-rotate(15deg); }
        }

        .liminal-indicator {
            position: absolute;
            top: 125px;
            right: 4px;
            background: rgba(139, 92, 246, 0.9);
            color: white;
            padding: 4px 10px;
            border-radius: 3px;
            font-size: 0.42rem;
            font-weight: bold;
            display: none;
            animation: liminal-glow 1s ease-in-out infinite;
        }

        .liminal-indicator.active { display: block; }

        @keyframes liminal-glow {
            0%, 100% { box-shadow: 0 0 5px rgba(139, 92, 246, 0.5); }
            50% { box-shadow: 0 0 15px rgba(139, 92, 246, 0.8); }
        }

        .log-entry.liminal { color: #a78bfa; }

        /* CEG Governance Mode Styles */
        .ceg-indicator {
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            padding: 3px 12px;
            border-radius: 3px;
            font-size: 0.5rem;
            font-weight: bold;
            color: white;
            z-index: 100;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .ceg-indicator .ceg-emoji { font-size: 0.6rem; }
        .ceg-indicator .ceg-label { letter-spacing: 0.5px; }
        .ceg-indicator .ceg-cycles {
            font-size: 0.4rem;
            opacity: 0.8;
            font-weight: normal;
        }

        .ceg-indicator.DEM {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.4);
        }

        .ceg-indicator.EPI {
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.4);
            animation: epi-pulse 2s ease-in-out infinite;
        }

        .ceg-indicator.SEN {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.4);
            animation: sen-pulse 1.5s ease-in-out infinite;
        }

        .ceg-indicator.EMG {
            background: linear-gradient(135deg, #ef4444, #b91c1c);
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.6);
            animation: emg-pulse 0.5s ease-in-out infinite;
        }

        @keyframes epi-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(139, 92, 246, 0.4); }
            50% { box-shadow: 0 0 20px rgba(139, 92, 246, 0.7); }
        }

        @keyframes sen-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(245, 158, 11, 0.4); }
            50% { box-shadow: 0 0 20px rgba(245, 158, 11, 0.7); }
        }

        @keyframes emg-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(239, 68, 68, 0.5); transform: translateX(-50%) scale(1); }
            50% { box-shadow: 0 0 25px rgba(239, 68, 68, 0.9); transform: translateX(-50%) scale(1.02); }
        }

        .ceg-pending {
            position: absolute;
            top: 28px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.38rem;
            color: #9ca3af;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .ceg-pending.active {
            opacity: 1;
        }

        .log-entry.ceg { color: #60a5fa; }
        .log-entry.ceg-epi { color: #a78bfa; }
        .log-entry.ceg-sen { color: #fbbf24; }
        .log-entry.ceg-emg { color: #f87171; }

        /* Advanced CEG Panel */
        .advanced-ceg-panel {
            position: absolute;
            bottom: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #374151;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 0.4rem;
            z-index: 100;
            min-width: 140px;
        }

        .advanced-ceg-panel .panel-title {
            color: #9ca3af;
            font-weight: bold;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .advanced-ceg-panel .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
            color: #d1d5db;
        }

        .advanced-ceg-panel .metric-label { color: #9ca3af; }
        .advanced-ceg-panel .metric-val { font-weight: bold; }
        .advanced-ceg-panel .metric-val.good { color: #4ade80; }
        .advanced-ceg-panel .metric-val.warn { color: #fbbf24; }
        .advanced-ceg-panel .metric-val.bad { color: #f87171; }

        .prediction-indicator {
            margin-top: 4px;
            padding: 3px 6px;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 3px;
            display: none;
        }

        .prediction-indicator.active { display: block; }

        .prediction-indicator .pred-icon { color: #a78bfa; }
        .prediction-indicator .pred-mode { color: #e0e7ff; font-weight: bold; }
        .prediction-indicator .pred-conf { color: #9ca3af; font-size: 0.35rem; }

        /* Oracle Beacons on Map */
        .oracle-beacon {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: radial-gradient(circle, #fbbf24 0%, rgba(251, 191, 36, 0) 70%);
            pointer-events: none;
            animation: oracle-pulse 2s ease-in-out infinite;
        }

        @keyframes oracle-pulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.5); opacity: 0.3; }
        }

        .memory-indicator {
            position: absolute;
            bottom: 4px;
            right: 140px;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.38rem;
            color: #9ca3af;
            display: none;
        }

        .memory-indicator.active { display: block; }
        .memory-indicator .mem-count { color: #a78bfa; font-weight: bold; }

        /* Oracle Disagreement Indicator */
        .oracle-status {
            position: absolute;
            bottom: 30px;
            left: 4px;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 0.38rem;
            color: #fbbf24;
        }

        .oracle-status .disagreement-bar {
            width: 60px;
            height: 4px;
            background: #374151;
            border-radius: 2px;
            margin-top: 2px;
            overflow: hidden;
        }

        .oracle-status .disagreement-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #fbbf24, #ef4444);
            transition: width 0.3s;
        }

        .oracle-status .drift-indicator {
            font-size: 0.35rem;
            color: #9ca3af;
            margin-top: 2px;
        }

        .shared-memory-indicator {
            position: absolute;
            bottom: 65px;
            left: 4px;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.4);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.38rem;
            color: #a78bfa;
            display: none;
        }

        .shared-memory-indicator.active { display: block; }

        .conflict-flash {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(239, 68, 68, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.45rem;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .conflict-flash.active {
            opacity: 1;
            animation: flash-pulse 0.5s ease-out;
        }

        @keyframes flash-pulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                              COMMAND CONSOLE STYLES
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

        .command-console {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(10, 5, 16, 0.98);
            border-top: 2px solid rgba(139, 92, 246, 0.5);
            z-index: 1000;
            transition: height 0.3s ease;
        }

        .command-console.collapsed {
            height: 36px;
        }

        .command-console.expanded {
            height: 200px;
        }

        .console-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 10px;
            background: rgba(139, 92, 246, 0.15);
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
            cursor: pointer;
        }

        .console-header h4 {
            font-size: 0.5rem;
            color: #8b5cf6;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .console-header .toggle-icon {
            font-size: 0.6rem;
            transition: transform 0.3s;
        }

        .command-console.expanded .toggle-icon {
            transform: rotate(180deg);
        }

        .console-output {
            height: calc(100% - 66px);
            overflow-y: auto;
            padding: 6px 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.42rem;
            line-height: 1.5;
        }

        .console-output::-webkit-scrollbar {
            width: 4px;
        }

        .console-output::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.3);
            border-radius: 2px;
        }

        .console-line {
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .console-line.input {
            color: #22d3ee;
        }

        .console-line.input::before {
            content: 'AION> ';
            color: #8b5cf6;
        }

        .console-line.output {
            color: #a0a0a0;
            padding-left: 12px;
        }

        .console-line.success {
            color: #4ade80;
        }

        .console-line.success::before {
            content: '‚úì ';
        }

        .console-line.error {
            color: #ef4444;
        }

        .console-line.error::before {
            content: '‚úó ';
        }

        .console-line.warning {
            color: #fbbf24;
        }

        .console-line.warning::before {
            content: '‚ö† ';
        }

        .console-line.info {
            color: #8b5cf6;
        }

        .console-line.info::before {
            content: '‚Üí ';
        }

        .console-line.system {
            color: #666;
            font-style: italic;
        }

        .console-input-row {
            display: flex;
            align-items: center;
            padding: 4px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid rgba(139, 92, 246, 0.2);
        }

        .console-prompt {
            color: #8b5cf6;
            font-family: 'Consolas', monospace;
            font-size: 0.45rem;
            margin-right: 6px;
        }

        .console-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #22d3ee;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.45rem;
            outline: none;
        }

        .console-input::placeholder {
            color: #444;
        }

        .console-status {
            display: flex;
            gap: 8px;
            font-size: 0.38rem;
        }

        .console-status .status-item {
            padding: 2px 6px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.3);
        }

        .console-status .ceg-mode {
            color: #4ade80;
        }

        .console-status .ceg-mode.dem { color: #22d3ee; }
        .console-status .ceg-mode.epi { color: #8b5cf6; }
        .console-status .ceg-mode.sen { color: #fbbf24; }
        .console-status .ceg-mode.emg { color: #ef4444; }

        .console-suggestions {
            position: absolute;
            bottom: 100%;
            left: 10px;
            right: 10px;
            background: rgba(15, 10, 20, 0.98);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 4px 4px 0 0;
            display: none;
            max-height: 120px;
            overflow-y: auto;
        }

        .console-suggestions.active {
            display: block;
        }

        .suggestion-item {
            padding: 4px 8px;
            font-size: 0.4rem;
            cursor: pointer;
            font-family: 'Consolas', monospace;
        }

        .suggestion-item:hover, .suggestion-item.selected {
            background: rgba(139, 92, 246, 0.2);
        }

        .suggestion-item .cmd {
            color: #22d3ee;
        }

        .suggestion-item .desc {
            color: #666;
            margin-left: 8px;
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>üåÄ AION MARS - Gateway Framework Edition</h1>
        <div class="pulse-indicator" id="pulse-indicator">üì° RECALIBRATION PULSE</div>
        <div class="header-stats">
            <div class="stat"><span class="val high" id="psi-val">1.00</span><span class="label">Œ® Coherence</span></div>
            <div class="stat"><span class="val" id="giant-val">100%</span><span class="label">Giant Comp</span></div>
            <div class="stat"><span class="val" id="arms-val">6</span><span class="label">Arms</span></div>
            <div class="stat"><span class="val" id="cascade-val">0.00</span><span class="label">Cascade</span></div>
            <div class="stat"><span class="val bad" id="fault-val">0</span><span class="label">Faults</span></div>
            <div class="stat"><span class="val" id="cycle-val">0000</span><span class="label">Cycle</span></div>
        </div>
    </div>

    <div class="main-layout">
        <!-- Left Panel: Controls -->
        <div class="panel" style="overflow-y: auto;">
            <div class="panel-header">‚öô Experiment Config</div>

            <div class="control-item">
                <label>Swarm Size</label>
                <select id="swarm-size" onchange="initExperiment()">
                    <option value="36">36 Drones</option>
                    <option value="49" selected>49 Drones</option>
                    <option value="64">64 Drones</option>
                    <option value="81">81 Drones</option>
                </select>
            </div>

            <div class="control-item">
                <label>Arm Count</label>
                <select id="arm-count" onchange="reassignArms()">
                    <option value="4">4 Arms</option>
                    <option value="6" selected>6 Arms</option>
                    <option value="8">8 Arms</option>
                </select>
            </div>

            <div class="control-item">
                <label>Œ≤ Mode</label>
                <select id="beta-mode">
                    <option value="octopus" selected>Octopus (Arm-Local)</option>
                    <option value="predictive">Predictive Cascade</option>
                    <option value="local">Local Only</option>
                    <option value="global">Global</option>
                    <option value="fixed">Fixed</option>
                </select>
            </div>

            <div class="control-item">
                <label>Simulation Speed</label>
                <input type="range" id="speed" min="20" max="200" value="80">
                <span style="font-size: 0.35rem; color: #666;" id="speed-display">80ms</span>
            </div>

            <div class="control-item">
                <label>Fault Rate (per 100 cycles)</label>
                <input type="range" id="fault-rate" min="0" max="10" value="2">
                <span style="font-size: 0.35rem; color: #666;" id="fault-rate-display">2%</span>
            </div>

            <div class="control-item">
                <label>Global Pulse Interval</label>
                <input type="number" id="pulse-interval" value="60" min="10" max="200">
            </div>

            <div class="control-item">
                <label>Local Pulse Interval</label>
                <input type="number" id="local-pulse-interval" value="20" min="5" max="100">
            </div>

            <div class="panel-header" style="margin-top: 4px;">üß¨ Bio Features</div>

            <div class="toggle-row">
                <button class="toggle-btn active" id="toggle-arms" onclick="toggleFeature('arms')">ü¶ë Arms</button>
                <button class="toggle-btn active" id="toggle-skin" onclick="toggleFeature('skin')">üé® Skin</button>
            </div>

            <div class="toggle-row">
                <button class="toggle-btn active" id="toggle-zooid" onclick="toggleFeature('zooid')">üî¨ Zooids</button>
                <button class="toggle-btn" id="toggle-vector" onclick="toggleFeature('vector')">üìê Vector</button>
            </div>

            <div class="toggle-row">
                <button class="toggle-btn active" id="toggle-wave" onclick="toggleFeature('wave')">üåä Waves</button>
                <button class="toggle-btn active" id="toggle-trit" onclick="toggleFeature('trit')">üî∫ Trit</button>
            </div>

            <div class="toggle-row">
                <button class="toggle-btn" id="toggle-storm" onclick="toggleStorm()">‚õàÔ∏è Storm</button>
                <button class="toggle-btn active" id="toggle-noise" onclick="toggleFeature('noise')">üì∂ Noise</button>
            </div>

            <div class="btn-row">
                <button class="btn" id="start-btn" onclick="toggleSim()">‚ñ∂</button>
                <button class="btn" onclick="stepSim()">‚Üí</button>
                <button class="btn" onclick="initExperiment()">‚Ü∫</button>
            </div>

            <div class="btn-row">
                <button class="btn danger" onclick="injectFault()">üí• Fault</button>
                <button class="btn pulse" onclick="manualPulse()">üì° Global</button>
            </div>

            <div class="btn-row">
                <button class="btn octopus" onclick="triggerBloom()">üå∏ Bloom</button>
                <button class="btn siphonophore" onclick="triggerGiantAxon()">‚ö° Axon</button>
            </div>

            <div class="panel-header" style="margin-top: 4px;">üî∫ Trit Voting</div>

            <div class="btn-row">
                <button class="btn trit-pos" onclick="injectTritVote(1)">+1</button>
                <button class="btn trit-zero" onclick="injectTritVote(0)">0</button>
                <button class="btn trit-neg" onclick="injectTritVote(-1)">-1</button>
            </div>

            <div class="btn-row">
                <button class="btn trit" onclick="sendTritWave()">üì° Trit Wave</button>
            </div>

            <div class="metric-section trit-section">
                <h4 class="trit">üî∫ Trit Distribution</h4>
                <div class="trit-distribution">
                    <div class="trit-box pos"><span class="count" id="trit-pos-count">0</span>+1</div>
                    <div class="trit-box zero"><span class="count" id="trit-zero-count">0</span>0</div>
                    <div class="trit-box neg"><span class="count" id="trit-neg-count">0</span>-1</div>
                </div>
                <div class="metric-row"><span class="label">Consensus</span><span class="val" id="trit-consensus">--</span></div>
                <div class="metric-row"><span class="label">Entropy</span><span class="val" id="trit-entropy">0.00</span></div>
                <div class="metric-row"><span class="label">Margin</span><span class="val" id="trit-margin">0%</span></div>
            </div>

            <div class="metric-section">
                <h4 class="arm">ü¶ë Arm Network</h4>
                <div class="arm-bar" id="arm-bar"></div>
                <div class="metric-row"><span class="label">Active Ganglia</span><span class="val" id="ganglia-count">6</span></div>
                <div class="metric-row"><span class="label">Intra-Arm Œ®</span><span class="val good" id="intra-arm-psi">1.00</span></div>
                <div class="metric-row"><span class="label">Exploring Arms</span><span class="val" id="exploring-arms">0</span></div>
            </div>

            <div class="metric-section">
                <h4 class="skin">üé® Skin Signaling</h4>
                <div class="metric-row"><span class="label">Optical Channel</span><span class="val" id="optical-strength">100%</span></div>
                <div class="metric-row"><span class="label">Red Waves</span><span class="val warn" id="red-waves">0</span></div>
                <div class="metric-row"><span class="label">Blue Rings</span><span class="val good" id="blue-rings">0</span></div>
            </div>
        </div>

        <!-- Center: Map -->
        <div class="panel" style="padding: 0;">
            <div class="map-container" id="map-container">
                <div class="dust-overlay" id="dust-overlay"></div>
                <div class="bloom-overlay" id="bloom-overlay"></div>
                <div class="bloom-indicator" id="bloom-indicator">üå∏ BLOOM MODE</div>
                <div class="liminal-overlay" id="liminal-overlay"></div>
                <div class="liminal-indicator" id="liminal-indicator">üåÄ LIMINAL COMPRESSION</div>
                <div class="ceg-indicator DEM" id="ceg-indicator">
                    <span class="ceg-emoji">üó≥Ô∏è</span>
                    <span class="ceg-label">DEMOCRATIC</span>
                    <span class="ceg-cycles">[0]</span>
                </div>
                <div class="ceg-pending" id="ceg-pending">‚Üí pending</div>
                <div class="overlay" id="map-overlay">CYCLE 0</div>
                <div class="component-indicator">
                    <div class="val" id="giant-big">49</div>
                    <div class="label">GIANT COMPONENT</div>
                </div>
                <div class="wave-indicator" id="wave-indicator" style="display: none;">
                    üåä METACHRONAL WAVE
                </div>
                <div class="consensus-indicator" id="consensus-indicator">
                    <div class="val" id="consensus-big">0</div>
                    <div class="label">TRIT CONSENSUS</div>
                </div>
                <div class="trit-wave-indicator" id="trit-wave-indicator">
                    üî∫ TRIT WAVE
                </div>
                <div class="noise-indicator" id="noise-indicator">
                    <div class="val" id="noise-avg">0.008</div>
                    <div class="label">AVG NOISE œÉ</div>
                </div>
                <div class="advanced-ceg-panel" id="advanced-ceg-panel">
                    <div class="panel-title">üß† ADVANCED CEG</div>
                    <div class="metric-row">
                        <span class="metric-label">Predictions</span>
                        <span class="metric-val" id="preemptive-count">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Memory Hits</span>
                        <span class="metric-val" id="memory-hits">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Memory Success</span>
                        <span class="metric-val" id="memory-success">50%</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Oracle Accuracy</span>
                        <span class="metric-val" id="oracle-accuracy">50%</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Calibrations</span>
                        <span class="metric-val" id="oracle-calibrations">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Conflicts</span>
                        <span class="metric-val" id="oracle-conflicts">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Inherited</span>
                        <span class="metric-val" id="memory-inherited">0</span>
                    </div>
                    <div class="prediction-indicator" id="prediction-indicator">
                        <span class="pred-icon">üîÆ</span>
                        <span class="pred-mode" id="pred-mode">--</span>
                        <span class="pred-conf" id="pred-conf">(0%)</span>
                    </div>
                </div>
                <div class="memory-indicator" id="memory-indicator">
                    üìö Episodes: <span class="mem-count" id="episode-count">0</span>
                </div>
                <div class="shared-memory-indicator" id="shared-memory-indicator">
                    üåê Shared: <span id="shared-pool-size">0</span> | Gen: <span id="memory-gen">0</span>
                </div>
                <div class="oracle-status" id="oracle-status">
                    ‚ú® Oracle Consensus
                    <div class="disagreement-bar">
                        <div class="disagreement-fill" id="disagreement-fill" style="width: 0%;"></div>
                    </div>
                    <div class="drift-indicator" id="drift-indicator">Drift: stable</div>
                </div>
                <div class="conflict-flash" id="conflict-flash">‚ö° ORACLE CONFLICT</div>
                <div id="oracle-container"></div>
                <canvas id="map-canvas"></canvas>
                <div class="legend">
                    <div class="legend-item"><div class="legend-dot" style="background: #8b5cf6;"></div> Base</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #f97316;"></div> Ganglion</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #4ade80;"></div> Normal</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #ef4444;"></div> Faulty</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #06b6d4;"></div> Nectophore</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #eab308;"></div> Gastrozooid</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #ec4899;"></div> Bract</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #22d3ee; border: 1px dashed #22d3ee;"></div> Eudoxid</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #666; opacity: 0.5;"></div> Detached</div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Metrics -->
        <div class="panel" style="overflow-y: auto;">
            <div class="panel-header">üìä Colony Analysis</div>

            <div class="giant-component-display">
                <div class="value" id="giant-display">49 / 49</div>
                <div class="label">Nodes in Largest Connected Subgraph</div>
            </div>

            <div class="component-bar" id="component-bar"></div>

            <div class="metric-row"><span class="label">Components</span><span class="val" id="num-components">1</span></div>
            <div class="metric-row"><span class="label">Giant %</span><span class="val good" id="giant-pct">100%</span></div>
            <div class="metric-row"><span class="label">Isolated</span><span class="val bad" id="isolated-count">0</span></div>

            <div class="panel-header" style="margin-top: 6px;">üî¨ Zooid Distribution</div>
            <div class="metric-section">
                <h4 class="zooid">Specialization</h4>
                <div class="metric-row"><span class="label">üöÄ Nectophores</span><span class="val" id="nectophore-count">0</span></div>
                <div class="metric-row"><span class="label">üëÅÔ∏è Gastrozooids</span><span class="val" id="gastrozooid-count">0</span></div>
                <div class="metric-row"><span class="label">üõ°Ô∏è Bracts</span><span class="val" id="bract-count">0</span></div>
                <div class="metric-row"><span class="label">‚ö™ Unspecialized</span><span class="val" id="unspec-count">0</span></div>
            </div>

            <div class="panel-header" style="margin-top: 6px;">üìê Vector State</div>
            <div class="metric-section">
                <div class="metric-row"><span class="label">Mean Œ∏ (orient)</span><span class="val" id="mean-theta">0.00</span></div>
                <div class="metric-row"><span class="label">Mean œÜ (sensor)</span><span class="val" id="mean-phi">0.00</span></div>
                <div class="metric-row"><span class="label">Covariance</span><span class="val" id="covariance">0.00</span></div>
            </div>

            <div class="panel-header" style="margin-top: 6px;">üìâ Timeline</div>
            <div class="chart-container">
                <canvas id="chart-canvas"></canvas>
            </div>

            <div class="metric-section">
                <h4 class="component">üìà Resilience</h4>
                <div class="metric-row"><span class="label">Fault Tolerance</span><span class="val" id="fault-tolerance">100%</span></div>
                <div class="metric-row"><span class="label">Recovery Rate</span><span class="val" id="recovery-rate">--</span></div>
                <div class="metric-row"><span class="label">Cascade Resist</span><span class="val" id="cascade-resistance">100%</span></div>
                <div class="metric-row"><span class="label">Self-Heals</span><span class="val good" id="heal-count">0</span></div>
            </div>

            <div class="metric-section">
                <h4 class="arm">ü¶ë Autotomy & Regen</h4>
                <div class="metric-row"><span class="label">Autotomies</span><span class="val warn" id="autotomy-count">0</span></div>
                <div class="metric-row"><span class="label">Regenerated</span><span class="val good" id="regen-count">0</span></div>
                <div class="metric-row"><span class="label">Regen Queue</span><span class="val" id="regen-queue">0</span></div>
                <div class="metric-row"><span class="label">Detached</span><span class="val bad" id="detached-count">0</span></div>
            </div>

            <div class="metric-section">
                <h4 class="zooid">üî¨ Eudoxids & Panic</h4>
                <div class="metric-row"><span class="label">Active Eudoxids</span><span class="val" id="eudoxid-count">0</span></div>
                <div class="metric-row"><span class="label">Tiles Revealed</span><span class="val good" id="eudoxid-tiles">0</span></div>
                <div class="metric-row"><span class="label">Panic Events</span><span class="val bad" id="panic-count">0</span></div>
                <div class="metric-row"><span class="label">Myogenic Waves</span><span class="val" id="myogenic-count">0</span></div>
            </div>

            <div class="metric-section trit-section">
                <h4 class="trit">üî∫ Trit Bandwidth</h4>
                <div class="metric-row"><span class="label">Before (64-bit)</span><span class="val" id="trit-bits-before">0 b</span></div>
                <div class="metric-row"><span class="label">After (5-bit)</span><span class="val good" id="trit-bits-after">0 b</span></div>
                <div class="metric-row"><span class="label">Compression</span><span class="val good" id="trit-compression">92%</span></div>
                <div class="metric-row"><span class="label">Transitions</span><span class="val" id="trit-transitions">0</span></div>
            </div>

            <div class="metric-section noise-section">
                <h4 class="noise">üì∂ Adaptive Noise</h4>
                <div class="noise-bar" id="noise-bar">
                    <div class="fill" id="noise-fill" style="width: 10%;"></div>
                    <div class="marker" id="noise-marker" style="left: 10%;"></div>
                </div>
                <div class="metric-row"><span class="label">œÉ Min</span><span class="val good" id="noise-min">0.008</span></div>
                <div class="metric-row"><span class="label">œÉ Avg</span><span class="val" id="noise-avg-val">0.008</span></div>
                <div class="metric-row"><span class="label">œÉ Max</span><span class="val warn" id="noise-max">0.008</span></div>
                <div class="metric-row"><span class="label">Variance</span><span class="val" id="noise-variance">0.000</span></div>
            </div>

            <div class="btn-row">
                <button class="btn export" onclick="exportCSV()">üìÑ CSV</button>
                <button class="btn export" onclick="exportJSON()">üìã JSON</button>
            </div>

            <div class="panel-header" style="margin-top: 6px;">üìù Event Log</div>
            <div class="log" id="log"></div>
        </div>
    </div>
</div>

<!-- Live Analysis Dashboard -->
<button class="dashboard-toggle" onclick="toggleDashboard()">üìä ANALYSIS</button>

<div class="dashboard-panel" id="dashboard-panel">
    <div class="dashboard-header">
        <h3>üìä Live Analysis Dashboard</h3>
        <span class="cycle" id="dash-cycle">Cycle 0</span>
    </div>

    <!-- Key Metrics Grid -->
    <div class="dashboard-grid">
        <div class="dashboard-card">
            <h4>Œ® Coherence</h4>
            <span class="value" id="dash-coherence" style="color: #ec4899;">0.00</span>
            <span class="trend stable" id="dash-coherence-trend">‚Üí</span>
            <div class="mini-chart"><canvas id="chart-coherence"></canvas></div>
        </div>
        <div class="dashboard-card">
            <h4>Giant Component</h4>
            <span class="value" id="dash-giant" style="color: #22d3ee;">100%</span>
            <span class="trend stable" id="dash-giant-trend">‚Üí</span>
            <div class="mini-chart"><canvas id="chart-giant"></canvas></div>
        </div>
        <div class="dashboard-card">
            <h4>Avg Noise œÉ</h4>
            <span class="value" id="dash-noise" style="color: #fbbf24;">0.008</span>
            <span class="trend stable" id="dash-noise-trend">‚Üí</span>
            <div class="mini-chart"><canvas id="chart-noise"></canvas></div>
        </div>
        <div class="dashboard-card">
            <h4>Fault Rate</h4>
            <span class="value" id="dash-faults" style="color: #ef4444;">0%</span>
            <span class="trend stable" id="dash-fault-trend">‚Üí</span>
            <div class="mini-chart"><canvas id="chart-faults"></canvas></div>
        </div>
    </div>

    <!-- Phase State Indicator -->
    <div class="phase-indicator">
        <div class="phase-dot stable" id="phase-dot"></div>
        <span class="phase-label stable" id="phase-label">STABLE</span>
        <span style="flex: 1;"></span>
        <span style="font-size: 0.35rem; color: #666;" id="phase-duration">0 cycles</span>
    </div>

    <!-- Correlation Matrix -->
    <div style="margin-top: 8px;">
        <div style="font-size: 0.4rem; color: #888; margin-bottom: 4px;">CORRELATION MATRIX</div>
        <div class="correlation-matrix" id="corr-matrix">
            <div class="corr-cell header"></div>
            <div class="corr-cell header">Œ®</div>
            <div class="corr-cell header">œÉ</div>
            <div class="corr-cell header">F</div>
            <div class="corr-cell header">Œ®</div>
            <div class="corr-cell neutral" id="corr-psi-psi">1.00</div>
            <div class="corr-cell neutral" id="corr-psi-noise">--</div>
            <div class="corr-cell neutral" id="corr-psi-fault">--</div>
            <div class="corr-cell header">œÉ</div>
            <div class="corr-cell neutral" id="corr-noise-psi">--</div>
            <div class="corr-cell neutral" id="corr-noise-noise">1.00</div>
            <div class="corr-cell neutral" id="corr-noise-fault">--</div>
            <div class="corr-cell header">F</div>
            <div class="corr-cell neutral" id="corr-fault-psi">--</div>
            <div class="corr-cell neutral" id="corr-fault-noise">--</div>
            <div class="corr-cell neutral" id="corr-fault-fault">1.00</div>
        </div>
    </div>

    <!-- Statistics Summary -->
    <div style="margin-top: 8px; background: rgba(0,0,0,0.3); padding: 6px; border-radius: 4px;">
        <div style="font-size: 0.4rem; color: #888; margin-bottom: 4px;">SESSION STATISTICS</div>
        <div class="stats-row"><span class="label">Total Cycles</span><span class="val" id="stat-cycles">0</span></div>
        <div class="stats-row"><span class="label">Avg Coherence</span><span class="val" id="stat-avg-psi">0.00</span></div>
        <div class="stats-row"><span class="label">Min Coherence</span><span class="val" id="stat-min-psi">0.00</span></div>
        <div class="stats-row"><span class="label">Total Faults</span><span class="val" id="stat-faults">0</span></div>
        <div class="stats-row"><span class="label">Total Heals</span><span class="val" id="stat-heals">0</span></div>
        <div class="stats-row"><span class="label">Phase Changes</span><span class="val" id="stat-phases">0</span></div>
        <div class="stats-row"><span class="label">Cascade Events</span><span class="val" id="stat-cascades">0</span></div>
    </div>

    <!-- Event Detection Log -->
    <div style="margin-top: 8px;">
        <div style="font-size: 0.4rem; color: #888; margin-bottom: 4px;">DETECTED EVENTS</div>
        <div class="event-log" id="event-log">
            <div class="event-item">
                <span class="type info">[0]</span>
                <span>Dashboard initialized</span>
            </div>
        </div>
    </div>

    <!-- Export -->
    <div style="margin-top: 8px; display: flex; gap: 4px;">
        <button class="btn export" onclick="exportAnalysis()" style="flex: 1;">üìä Export Analysis</button>
        <button class="btn" onclick="resetAnalysis()" style="flex: 1;">‚Ü∫ Reset</button>
    </div>
</div>

<script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    GATEWAY FRAMEWORK CONSTANTS
    //                    All derived from Œì = 1/(6œÜ)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // TIER 0: IMMUTABLE PRIMITIVES
    const PHI = (1 + Math.sqrt(5)) / 2;       // 1.6180339887498949 - Golden Ratio
    const GAMMA = 1 / (6 * PHI);              // 0.103005664791649 - Gate Constant

    // TIER 1: EXACT IDENTITIES
    const PHI_GAMMA = PHI * GAMMA;            // 1/6 = 0.16666... EXACT
    const SIX_GAMMA = 6 * GAMMA;              // 1/œÜ = 0.61803... EXACT
    const INVERSE_PHI = 1 / PHI;              // 0.61803... = œÜ-1
    const KOIDE = 4 * PHI * GAMMA;            // 2/3 = 0.66666... EXACT (Koide Ratio)

    // TIER 2: SAFETY THRESHOLDS
    const CLAMP_HIGH = 1 - GAMMA;             // 0.896994... (handoff threshold)
    const CLAMP_LOW = GAMMA;                  // 0.103005... (reset threshold)
    const HYSTERESIS_BAND = PHI_GAMMA;        // 1/6 = 0.16666...
    const SIGMOID_K = 6 * PHI;                // 9.708203932499369

    // Gateway-derived core constants
    const BETA_BASE = CLAMP_HIGH;             // 0.897 (was 0.85)
    const BETA_MIN = KOIDE - GAMMA;           // 0.564 (was 0.55)
    const ALPHA = 0.0005;                     // (unchanged - empirical)
    const SIGMA = 0.008;                      // (unchanged - empirical)

    // Signal
    const SIGNAL_RANGE = 3.2;                 // (unchanged - geometric)
    const SIGNAL_LOST_THRESHOLD = PHI_GAMMA;  // 0.167 (was 0.15)
    const OPTICAL_RANGE = 1.8;                // Shorter range for skin-based optical signaling

    // Cascade
    const CASCADE_WEIGHT = 0.1;               // (unchanged)
    const CASCADE_THRESHOLD = KOIDE + GAMMA;  // 0.77 (was 0.75)

    // Pulse
    const PULSE_ATTRACTOR = INVERSE_PHI - GAMMA; // 0.515 (was 0.5507)

    // Arm/Octopus
    const ARM_LOCAL_BETA_BOOST = 0.08;  // Higher Œ≤ retention within arm
    const EXPLORE_SIGNAL_BOOST = 0.3;   // Lower threshold when exploring

    // Skin/Camouflage
    const SKIN_INFLUENCE = 0.05;  // How much neighbor skin state affects Œ≤
    const RED_WAVE_THRESHOLD = 0.7;  // Œ≤ below this triggers red wave
    const BLUE_RING_COHERENCE = 0.9;  // Œ® above this shows blue rings

    // Zooid Specialization
    const NECTOPHORE_SPEED_MULT = 1.5;
    const GASTROZOOID_EXPLORE_MULT = 2.0;
    const BRACT_FAULT_RESIST = 0.5;  // 50% chance to resist fault

    // Metachronal
    const WAVE_SPEED = 0.15;
    const WAVE_DURATION = 30;

    // Self-healing (Gateway-derived)
    const HEAL_PROBABILITY = GAMMA / 50;     // 0.00206 (was 0.002)
    const HEAL_NEIGHBOR_THRESHOLD = 3;       // Need 3+ healthy neighbors

    // Polarization Channel (ignores dust)
    const POLARIZATION_RANGE = 2.5;          // Slightly longer than optical
    const POLARIZATION_STRENGTH = 0.08;      // Arm-to-arm coordination boost

    // Autotomy & Regeneration (Gateway-derived)
    const AUTOTOMY_STRESS_THRESHOLD = BETA_MIN - GAMMA; // 0.461 (was 0.4)
    const AUTOTOMY_FAULT_RATIO = 0.5;        // >50% faulty drones in arm triggers autotomy
    const REGEN_RATE = GAMMA / 20;           // 0.00515 (was 0.005)
    const MAX_REGEN_QUEUE = 3;               // Max drones queued for regeneration

    // Giant Axon Panic
    const PANIC_FAULT_THRESHOLD = 0.3;  // >30% faults triggers panic
    const PANIC_STORM_THRESHOLD = 0.85;  // Storm intensity triggers panic
    const PANIC_COOLDOWN = 50;  // Cycles between panic broadcasts

    // Myogenic Skin Waves
    const MYOGENIC_PROPAGATION = 0.15;  // Chance to spread wave to neighbor
    const MYOGENIC_DECAY = 0.92;  // Wave intensity decay per hop

    // Eudoxid Release
    const EUDOXID_SATURATION_THRESHOLD = 0.9;  // Arm coherence to release eudoxid
    const EUDOXID_SIZE = 3;  // Drones per eudoxid sub-swarm
    const EUDOXID_RANGE = 4;  // How far eudoxids explore
    const EUDOXID_LIFESPAN = 80;  // Cycles before eudoxid returns

    // Terrain
    const TERRAIN = { UNKNOWN: 0, SAFE: 1, OBSTACLE: 2 };

    // Adaptive Noise Scaling
    const SIGMA_BASE = 0.008;           // Base noise level
    const SIGMA_OBSTACLE_MULT = 2.5;    // Noise multiplier near obstacles
    const SIGMA_UNEXPLORED_MULT = 1.8;  // Noise multiplier in unexplored areas
    const SIGMA_STORM_MULT = 3.0;       // Maximum storm noise multiplier
    const SIGMA_DENSITY_REDUCTION = 0.3; // Noise reduction from neighbor density
    const SIGMA_ARM_COHERENCE_MULT = 0.5; // Low arm coherence increases noise
    const NOISE_SMOOTHING = 0.7;        // Temporal smoothing for noise changes

    // Trit System (Hybrid Ternary Layer) - Gateway-derived
    const TRIT = { NEG: -1, ZERO: 0, POS: 1 };
    const TRIT_THRESHOLD_POS = PHI_GAMMA + GAMMA / 3;  // 0.201 (was 0.2)
    const TRIT_THRESHOLD_NEG = -TRIT_THRESHOLD_POS;    // -0.201
    const VOTE_INERTIA = KOIDE + GAMMA / 3;            // 0.701 (was 0.7)
    const TRIT_NEIGHBOR_INFLUENCE = KOIDE / 2;         // 0.333 (was 0.3)
    const CONSENSUS_THRESHOLD_DEFAULT = KOIDE;         // 0.6666... EXACT (was 0.66)
    const TRIT_WAVE_SPEED = 0.2;
    const TRIT_WAVE_WIDTH = 0.4;

    // Liminal / Compression Mode - Gateway-derived
    const LIMINAL_TRIGGER_ENTROPY = CLAMP_HIGH - GAMMA;   // 0.794 (was 0.78)
    const LIMINAL_TRIGGER_FLIPRATE = GAMMA + GAMMA / 10;  // 0.113 (was 0.12)
    const LIMINAL_MAX_CYCLES = Math.round(72 / 6);        // 12 cycles (exact)
    const LIMINAL_BETA_BOOST = GAMMA / 5;                 // 0.0206 (was 0.02)

    // Contextual Epistemic Governance (CEG) - Gateway-derived
    const CEG_MODE = { DEM: 'DEM', EPI: 'EPI', SEN: 'SEN', EMG: 'EMG' };
    const CEG_LABELS = {
        DEM: 'DEMOCRATIC',
        EPI: 'EPISTEMIC',
        SEN: 'SENTINEL',
        EMG: 'EMERGENCY'
    };
    // Transition thresholds (Gateway-derived)
    const CEG_ENTROPY_LOW = KOIDE / 2;              // 0.333 (was 0.35)
    const CEG_ENTROPY_MID = KOIDE - GAMMA;          // 0.564 (was 0.55)
    const CEG_ENTROPY_HIGH = CLAMP_HIGH - PHI_GAMMA; // 0.730 (was 0.72)
    const CEG_FLIPRATE_LOW = 0.04;                  // (unchanged)
    const CEG_FLIPRATE_HIGH = GAMMA;                // 0.103 (was 0.10)
    const CEG_FAULT_THRESHOLD = KOIDE - 0.4;        // 0.267 (was 0.25)
    const CEG_FAULT_CRITICAL = AUTOTOMY_STRESS_THRESHOLD; // 0.461 (was 0.40)
    const CEG_SIGNAL_COLLAPSE = KOIDE / 2;          // 0.333 (was 0.30)
    // Hysteresis settings
    const CEG_HYSTERESIS_CYCLES = Math.round(72 / 9); // 8 cycles (exact)
    const CEG_STABILITY_WINDOW = 5;                 // (unchanged)
    // Epistemic weighting factors (Gateway-derived)
    const EPI_GANGLION_WEIGHT = PHI - GAMMA;        // 1.515 (was 1.5)
    const EPI_STABILITY_WEIGHT = KOIDE / 2;         // 0.333 (was 0.3)
    const EPI_TRACK_RECORD_DECAY = 1 - GAMMA / 2;   // 0.948 (was 0.95)
    // Mode-specific parameters (Gateway-derived)
    const CEG_BETA_MODS = {
        DEM: 0,
        EPI: GAMMA / 10,         // 0.0103 (was 0.01)
        SEN: GAMMA / 3,          // 0.0343 (was 0.03)
        EMG: GAMMA / 2           // 0.0515 (was 0.05)
    };
    const CEG_COUPLING_MODS = {
        DEM: 1.0,
        EPI: 1 + GAMMA,          // 1.103 (was 1.1)
        SEN: CLAMP_HIGH - GAMMA, // 0.794 (was 0.8)
        EMG: KOIDE - GAMMA       // 0.564 (was 0.6)
    };
    const CEG_CONSENSUS_THRESH = {
        DEM: KOIDE,              // 0.6666... (was 0.66)
        EPI: KOIDE - GAMMA / 10, // 0.656 (was 0.60)
        SEN: KOIDE - GAMMA,      // 0.564 (was 0.55)
        EMG: 0.5 + GAMMA / 10    // 0.510 (was 0.51)
    };

    // Predictive Mode Selection
    const PREDICT_WINDOW = 10;              // Cycles to analyze for trend
    const PREDICT_ENTROPY_VELOCITY = 0.03;  // Entropy rise per cycle triggers preemption
    const PREDICT_FLIPRATE_ACCEL = 0.005;   // Flip rate acceleration threshold
    const PREDICT_LOOKAHEAD = 5;            // Cycles to project forward
    const PREDICT_CONFIDENCE_THRESH = 0.7;  // Confidence needed to act on prediction

    // Epistemic Memory Consolidation
    const MEMORY_MAX_EPISODES = 20;         // Max crisis episodes to remember
    const MEMORY_DECAY = 0.98;              // How fast old memories fade

    // Memory Management Limits (prevent freeze on long runs)
    const MAX_EXPERIMENT_DATA = 5000;       // Limit experiment data points
    const MAX_CEG_HISTORY = 500;            // Limit CEG mode history
    const MAX_AUTOTOMY_EVENTS = 200;        // Limit autotomy event log
    const MAX_PSI_GAINS = 100;              // Limit pulse gain history
    const MAX_FAULTS = 500;                 // Limit fault tracking
    const MEMORY_SIMILARITY_THRESH = 0.15;  // How close conditions must be to match
    const MEMORY_SUCCESS_BONUS = 0.1;       // Track record boost for successful resolution
    const MEMORY_FAILURE_PENALTY = 0.05;    // Track record penalty for failed resolution

    // External Oracle System
    const ORACLE_COUNT = 3;                 // Number of oracle beacons
    const ORACLE_RANGE = 2.0;               // Range of oracle influence
    const ORACLE_STRENGTH = 0.8;            // How strongly oracle affects nearby drones
    const ORACLE_TRUTH_VARIANCE = 0.1;      // How much oracle truth varies
    const ORACLE_CALIBRATION_RATE = 0.02;   // How fast drones calibrate to oracle
    const ORACLE_BROADCAST_INTERVAL = 25;   // Cycles between oracle broadcasts

    // Multi-Oracle Consensus
    const ORACLE_DISAGREEMENT_THRESH = 0.5; // Oracles disagree if diff > this
    const ORACLE_CONSENSUS_WEIGHT = 0.6;    // Weight given to consensus oracle
    const ORACLE_MINORITY_WEIGHT = 0.25;    // Weight given to dissenting oracle
    const ORACLE_CONFLICT_PENALTY = 0.1;    // Track record penalty for conflicting info

    // Temporal Oracle Drift
    const ORACLE_DRIFT_RATE = 0.005;        // How fast oracle truth drifts per cycle
    const ORACLE_DRIFT_VARIANCE = 0.02;     // Randomness in drift direction
    const ORACLE_DRIFT_REVERSAL = 0.01;     // Chance of drift direction reversal
    const ORACLE_TRUTH_BOUNDS = 1.2;        // Max absolute truth value

    // Cross-Swarm Memory Sharing
    const MEMORY_SHARE_INTERVAL = 100;      // Cycles between memory broadcasts
    const MEMORY_SHARE_COUNT = 3;           // Top N episodes to share
    const MEMORY_INHERITANCE_WEIGHT = 0.7;  // Weight of inherited vs own memory
    const MEMORY_GENERATION_DECAY = 0.9;    // How much inherited memories fade
    const SHARED_MEMORY_POOL_SIZE = 10;     // Max shared memories to keep

    // Arm colors (for visualization)
    const ARM_COLORS = [
        '#ef4444', '#f97316', '#eab308', '#22c55e', '#06b6d4', '#8b5cf6', '#ec4899', '#f43f5e'
    ];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    STATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let terrain = [];
    let terrainSize = 40;
    let drones = [];
    let base = null;
    let cycle = 0;
    let isRunning = false;
    let timer = null;

    // Feature toggles
    let features = {
        arms: true,
        skin: true,
        zooid: true,
        vector: false,
        wave: true,
        trit: true,  // Hybrid ternary voting layer
        noise: true  // Adaptive noise visualization
    };

    // Seeded RNG
    let rngSeed = 42;
    function seededRandom() {
        rngSeed = (rngSeed * 9301 + 49297) % 233280;
        return rngSeed / 233280;
    }

    function safeMod(n, m) { return ((n % m) + m) % m; }

    // Weather
    let weather = { stormIntensity: 0, stormPhase: 'clear', stormDuration: 0, nextStormCycle: 200, manualStorm: false };

    // Faults
    let faults = [];
    let healCount = 0;

    // Arms (Octopus)
    let arms = [];  // [{id, drones: [], ganglionId, lastLocalPulse, exploring}]

    // Pulse tracking
    let pulseStats = { count: 0, lastCycle: null, nextCycle: 60, psiGains: [], localPulses: 0 };

    // Metachronal wave
    let activeWave = null;  // {origin, cycle, direction}

    // Bloom mode
    let bloomActive = false;
    let bloomCycles = 0;

    // Autotomy & Regeneration
    let autotomyEvents = [];  // [{armId, cycle, dronesLost}]
    let regenQueue = [];  // [{armId, cycleQueued}]
    let totalAutotomies = 0;
    let totalRegens = 0;

    // Giant Axon Panic
    let lastPanicCycle = -100;
    let panicCount = 0;

    // Myogenic Waves
    let myogenicWaves = [];  // [{droneId, intensity, color, cycle}]

    // Eudoxids
    let eudoxids = [];  // [{id, drones: [], origin, target, birthCycle, armId}]
    let eudoxidIdCounter = 0;

    // Trit System State
    let tritWaveActive = false;
    let tritWaveOrigin = null;
    let tritWaveRadius = 0;
    let tritWaveValue = TRIT.ZERO;
    let tritTransitions = { posToZero: 0, zeroToNeg: 0, negToPos: 0, total: 0 };
    let voteHistory = [];
    let consensusHistory = [];

    // Liminal / Compression Mode State
    let liminalMode = false;
    let liminalCycles = 0;
    let totalLiminalEvents = 0;

    // Contextual Epistemic Governance (CEG) State
    let cegMode = CEG_MODE.DEM;             // Current governance mode
    let cegCyclesInMode = 0;                // Cycles spent in current mode
    let cegPendingMode = null;              // Mode we're transitioning to
    let cegPendingCycles = 0;               // Cycles confirming pending transition
    let cegModeHistory = [];                // [{mode, startCycle, endCycle, reason}]
    let cegEffectiveBeta = 0;               // Current beta modifier from CEG
    let cegEffectiveCoupling = 1.0;         // Current coupling modifier from CEG
    let cegEffectiveConsensus = 0.66;       // Current consensus threshold
    let totalModeTransitions = 0;           // Total mode changes

    // Predictive Mode Selection State
    let metricHistory = {
        entropy: [],
        flipRate: [],
        coherence: [],
        faults: []
    };
    let predictedMode = null;               // What we predict will be needed
    let predictionConfidence = 0;           // How confident the prediction is
    let preemptiveTransitions = 0;          // Count of predictive transitions

    // Epistemic Memory Consolidation State
    let epistemicMemory = [];               // [{conditions, mode, resolution, cycles, success}]
    let currentEpisode = null;              // Active crisis episode being tracked
    let memoryHits = 0;                     // Times memory informed a decision
    let memorySuccessRate = 0.5;            // Rolling success rate

    // External Oracle System State
    let oracles = [];                       // [{x, y, truthValue, lastBroadcast, driftDirection}]
    let oracleCalibrations = 0;             // Total calibration events
    let oracleAccuracy = 0.5;               // Swarm-wide accuracy vs oracle truth

    // Multi-Oracle Consensus State
    let oracleConsensusValue = 0;           // Current consensus truth
    let oracleDisagreement = 0;             // How much oracles disagree (0-1)
    let oracleConflictEvents = 0;           // Times drones received conflicting info

    // Temporal Oracle Drift State
    let totalOracleDrift = 0;               // Cumulative drift amount
    let driftReversals = 0;                 // Number of drift direction changes

    // Cross-Swarm Memory Sharing State
    let sharedMemoryPool = [];              // [{episode, source, generation, weight}]
    let lastMemoryShare = 0;                // Cycle of last memory broadcast
    let memoryInheritanceCount = 0;         // Times we inherited shared memory
    let memoryGenerations = 0;              // Current memory generation

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    LIVE ANALYSIS DASHBOARD
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Dashboard state
    let dashboardVisible = false;
    const ANALYSIS_BUFFER_SIZE = 100;  // Rolling window size

    // Rolling data buffers for analysis
    let analysisBuffers = {
        coherence: [],
        giant: [],
        noise: [],
        faults: [],
        cascading: []
    };

    // Session statistics
    let sessionStats = {
        totalCycles: 0,
        coherenceSum: 0,
        minCoherence: 1.0,
        maxCoherence: 0,
        totalFaults: 0,
        totalHeals: 0,
        phaseChanges: 0,
        cascadeEvents: 0
    };

    // Phase tracking
    let currentPhase = 'stable';  // stable, transition, critical
    let phaseStartCycle = 0;
    let previousPhase = 'stable';

    // Event detection thresholds
    const EVENT_THRESHOLDS = {
        coherenceDrop: 0.15,      // Sudden coherence drop
        coherenceSpike: 0.1,      // Sudden coherence increase
        noiseSpike: 0.02,         // Noise spike detection
        cascadeStart: 3,          // Drones cascading to trigger alert
        faultBurst: 2,            // Multiple faults in short time
        phaseTransition: 0.6      // Coherence threshold for phase change
    };

    // Detected events log
    let detectedEvents = [];

    function toggleDashboard() {
        dashboardVisible = !dashboardVisible;
        document.getElementById('dashboard-panel').classList.toggle('active', dashboardVisible);
    }

    // Add data point to rolling buffers
    function updateAnalysisBuffers(coherence, giantPct, avgNoise, faultRate, cascading) {
        analysisBuffers.coherence.push(coherence);
        analysisBuffers.giant.push(giantPct);
        analysisBuffers.noise.push(avgNoise);
        analysisBuffers.faults.push(faultRate);
        analysisBuffers.cascading.push(cascading);

        // Keep buffer size limited
        Object.keys(analysisBuffers).forEach(key => {
            if (analysisBuffers[key].length > ANALYSIS_BUFFER_SIZE) {
                analysisBuffers[key].shift();
            }
        });

        // Update session stats
        sessionStats.totalCycles++;
        sessionStats.coherenceSum += coherence;
        sessionStats.minCoherence = Math.min(sessionStats.minCoherence, coherence);
        sessionStats.maxCoherence = Math.max(sessionStats.maxCoherence, coherence);
    }

    // Compute correlation between two arrays
    function computeCorrelation(arr1, arr2) {
        if (arr1.length < 10 || arr2.length < 10) return 0;

        const n = Math.min(arr1.length, arr2.length);
        const mean1 = arr1.slice(-n).reduce((a, b) => a + b, 0) / n;
        const mean2 = arr2.slice(-n).reduce((a, b) => a + b, 0) / n;

        let num = 0, den1 = 0, den2 = 0;
        for (let i = 0; i < n; i++) {
            const d1 = arr1[arr1.length - n + i] - mean1;
            const d2 = arr2[arr2.length - n + i] - mean2;
            num += d1 * d2;
            den1 += d1 * d1;
            den2 += d2 * d2;
        }

        const den = Math.sqrt(den1 * den2);
        return den > 0 ? num / den : 0;
    }

    // Compute trend (up, down, stable)
    function computeTrend(arr, windowSize = 10) {
        if (arr.length < windowSize) return 'stable';

        const recent = arr.slice(-windowSize);
        const older = arr.slice(-windowSize * 2, -windowSize);

        if (older.length < windowSize) return 'stable';

        const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
        const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;

        const diff = recentAvg - olderAvg;
        const threshold = olderAvg * 0.05;  // 5% change threshold

        if (diff > threshold) return 'up';
        if (diff < -threshold) return 'down';
        return 'stable';
    }

    // Detect phase state
    function detectPhase(coherence, faultRate, cascading) {
        let phase = 'stable';

        if (coherence < 0.4 || faultRate > 0.3 || cascading > 5) {
            phase = 'critical';
        } else if (coherence < 0.7 || faultRate > 0.1 || cascading > 2) {
            phase = 'transition';
        }

        if (phase !== currentPhase) {
            previousPhase = currentPhase;
            currentPhase = phase;
            phaseStartCycle = cycle;
            sessionStats.phaseChanges++;

            addDetectedEvent(
                phase === 'critical' ? 'critical' : phase === 'transition' ? 'warning' : 'success',
                `Phase: ${previousPhase} ‚Üí ${phase}`
            );
        }

        return phase;
    }

    // Event detection
    function detectEvents(coherence, avgNoise, faultRate, cascading) {
        const bufLen = analysisBuffers.coherence.length;
        if (bufLen < 2) return;

        const prevCoherence = analysisBuffers.coherence[bufLen - 2] || coherence;
        const prevNoise = analysisBuffers.noise[bufLen - 2] || avgNoise;

        // Coherence drop
        if (prevCoherence - coherence > EVENT_THRESHOLDS.coherenceDrop) {
            addDetectedEvent('critical', `Coherence drop: ${prevCoherence.toFixed(2)} ‚Üí ${coherence.toFixed(2)}`);
        }

        // Coherence recovery
        if (coherence - prevCoherence > EVENT_THRESHOLDS.coherenceSpike) {
            addDetectedEvent('success', `Coherence spike: ${prevCoherence.toFixed(2)} ‚Üí ${coherence.toFixed(2)}`);
        }

        // Noise spike
        if (avgNoise - prevNoise > EVENT_THRESHOLDS.noiseSpike) {
            addDetectedEvent('warning', `Noise spike: œÉ ${avgNoise.toFixed(4)}`);
        }

        // Cascade start
        if (cascading >= EVENT_THRESHOLDS.cascadeStart && analysisBuffers.cascading[bufLen - 2] < EVENT_THRESHOLDS.cascadeStart) {
            addDetectedEvent('critical', `Cascade started: ${cascading} drones`);
            sessionStats.cascadeEvents++;
        }
    }

    // Add event to log
    function addDetectedEvent(type, message) {
        detectedEvents.unshift({ cycle, type, message, time: Date.now() });
        if (detectedEvents.length > 50) detectedEvents.pop();

        // Update UI
        const logEl = document.getElementById('event-log');
        if (logEl) {
            const item = document.createElement('div');
            item.className = 'event-item';
            item.innerHTML = `<span class="type ${type}">[${cycle}]</span><span>${message}</span>`;
            logEl.prepend(item);
            while (logEl.children.length > 15) logEl.lastChild.remove();
        }
    }

    // Draw mini chart
    function drawMiniChart(canvasId, data, color, minVal = 0, maxVal = 1) {
        const canvas = document.getElementById(canvasId);
        if (!canvas || data.length < 2) return;

        const ctx = canvas.getContext('2d');
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const w = canvas.width;
        const h = canvas.height;
        const p = 2;

        // Draw line
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();

        data.forEach((val, i) => {
            const x = p + (i / (data.length - 1)) * (w - 2 * p);
            const normalized = (val - minVal) / (maxVal - minVal);
            const y = h - p - Math.max(0, Math.min(1, normalized)) * (h - 2 * p);

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.stroke();

        // Fill area under
        ctx.lineTo(w - p, h - p);
        ctx.lineTo(p, h - p);
        ctx.closePath();
        ctx.fillStyle = color.replace('1)', '0.15)').replace('rgb', 'rgba');
        ctx.fill();
    }

    // Update dashboard display
    function updateDashboard() {
        if (!dashboardVisible) return;

        const order = computeOrderParameter();
        const components = computeConnectedComponents();
        const noiseStats = getNoiseStats();
        const cascading = drones.filter(d => d.isCascading).length;
        const faultRate = faults.length / drones.length;
        const giantPct = components.giantSize / drones.length;

        // Update buffers
        updateAnalysisBuffers(order.coherence, giantPct, noiseStats.avg, faultRate, cascading);

        // Detect phase and events
        detectPhase(order.coherence, faultRate, cascading);
        detectEvents(order.coherence, noiseStats.avg, faultRate, cascading);

        // Update cycle
        document.getElementById('dash-cycle').textContent = `Cycle ${cycle}`;

        // Update main metrics
        document.getElementById('dash-coherence').textContent = order.coherence.toFixed(3);
        document.getElementById('dash-giant').textContent = (giantPct * 100).toFixed(1) + '%';
        document.getElementById('dash-noise').textContent = noiseStats.avg.toFixed(4);
        document.getElementById('dash-faults').textContent = (faultRate * 100).toFixed(1) + '%';

        // Update trends
        const trends = {
            coherence: computeTrend(analysisBuffers.coherence),
            giant: computeTrend(analysisBuffers.giant),
            noise: computeTrend(analysisBuffers.noise),
            faults: computeTrend(analysisBuffers.faults)
        };

        const trendSymbols = { up: '‚Üë', down: '‚Üì', stable: '‚Üí' };
        document.getElementById('dash-coherence-trend').textContent = trendSymbols[trends.coherence];
        document.getElementById('dash-coherence-trend').className = 'trend ' + trends.coherence;
        document.getElementById('dash-giant-trend').textContent = trendSymbols[trends.giant];
        document.getElementById('dash-giant-trend').className = 'trend ' + trends.giant;
        document.getElementById('dash-noise-trend').textContent = trendSymbols[trends.noise];
        document.getElementById('dash-noise-trend').className = 'trend ' + (trends.noise === 'up' ? 'down' : trends.noise === 'down' ? 'up' : 'stable');
        document.getElementById('dash-fault-trend').textContent = trendSymbols[trends.faults];
        document.getElementById('dash-fault-trend').className = 'trend ' + (trends.faults === 'up' ? 'down' : trends.faults === 'down' ? 'up' : 'stable');

        // Update mini charts
        drawMiniChart('chart-coherence', analysisBuffers.coherence, 'rgba(236, 72, 153, 1)', 0, 1);
        drawMiniChart('chart-giant', analysisBuffers.giant, 'rgba(34, 211, 238, 1)', 0, 1);
        drawMiniChart('chart-noise', analysisBuffers.noise, 'rgba(251, 191, 36, 1)', 0, 0.05);
        drawMiniChart('chart-faults', analysisBuffers.faults, 'rgba(239, 68, 68, 1)', 0, 0.5);

        // Update phase indicator
        const phaseDot = document.getElementById('phase-dot');
        const phaseLabel = document.getElementById('phase-label');
        phaseDot.className = 'phase-dot ' + currentPhase;
        phaseLabel.className = 'phase-label ' + currentPhase;
        phaseLabel.textContent = currentPhase.toUpperCase();
        document.getElementById('phase-duration').textContent = `${cycle - phaseStartCycle} cycles`;

        // Update correlation matrix
        if (analysisBuffers.coherence.length >= 20) {
            const corrPsiNoise = computeCorrelation(analysisBuffers.coherence, analysisBuffers.noise);
            const corrPsiFault = computeCorrelation(analysisBuffers.coherence, analysisBuffers.faults);
            const corrNoiseFault = computeCorrelation(analysisBuffers.noise, analysisBuffers.faults);

            updateCorrCell('corr-psi-noise', corrPsiNoise);
            updateCorrCell('corr-noise-psi', corrPsiNoise);
            updateCorrCell('corr-psi-fault', corrPsiFault);
            updateCorrCell('corr-fault-psi', corrPsiFault);
            updateCorrCell('corr-noise-fault', corrNoiseFault);
            updateCorrCell('corr-fault-noise', corrNoiseFault);
        }

        // Update session stats
        document.getElementById('stat-cycles').textContent = sessionStats.totalCycles;
        document.getElementById('stat-avg-psi').textContent = (sessionStats.coherenceSum / Math.max(1, sessionStats.totalCycles)).toFixed(3);
        document.getElementById('stat-min-psi').textContent = sessionStats.minCoherence.toFixed(3);
        document.getElementById('stat-faults').textContent = sessionStats.totalFaults;
        document.getElementById('stat-heals').textContent = sessionStats.totalHeals;
        document.getElementById('stat-phases').textContent = sessionStats.phaseChanges;
        document.getElementById('stat-cascades').textContent = sessionStats.cascadeEvents;
    }

    function updateCorrCell(id, value) {
        const el = document.getElementById(id);
        if (!el) return;

        el.textContent = value.toFixed(2);
        el.className = 'corr-cell ' + (value > 0.3 ? 'pos' : value < -0.3 ? 'neg' : 'neutral');
    }

    function resetAnalysis() {
        analysisBuffers = { coherence: [], giant: [], noise: [], faults: [], cascading: [] };
        sessionStats = { totalCycles: 0, coherenceSum: 0, minCoherence: 1.0, maxCoherence: 0, totalFaults: 0, totalHeals: 0, phaseChanges: 0, cascadeEvents: 0 };
        detectedEvents = [];
        currentPhase = 'stable';
        phaseStartCycle = cycle;

        document.getElementById('event-log').innerHTML = '<div class="event-item"><span class="type info">[' + cycle + ']</span><span>Analysis reset</span></div>';
    }

    function exportAnalysis() {
        const analysis = {
            metadata: {
                exportTime: new Date().toISOString(),
                totalCycles: sessionStats.totalCycles,
                swarmSize: drones.length
            },
            sessionStats,
            correlations: {
                psiNoise: computeCorrelation(analysisBuffers.coherence, analysisBuffers.noise),
                psiFault: computeCorrelation(analysisBuffers.coherence, analysisBuffers.faults),
                noiseFault: computeCorrelation(analysisBuffers.noise, analysisBuffers.faults)
            },
            buffers: analysisBuffers,
            events: detectedEvents.slice(0, 100)
        };

        downloadFile(JSON.stringify(analysis, null, 2), 'aion_analysis_' + Date.now() + '.json', 'application/json');
    }

    // Data collection
    let experimentData = [];
    let coherenceHistory = [];
    let giantHistory = [];
    let armCoherenceHistory = [];
    const MAX_HISTORY = 150;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    UNION-FIND
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    class UnionFind {
        constructor(n) {
            this.parent = Array.from({length: n}, (_, i) => i);
            this.rank = new Array(n).fill(0);
            this.size = new Array(n).fill(1);
        }

        find(x) {
            if (this.parent[x] !== x) {
                this.parent[x] = this.find(this.parent[x]);
            }
            return this.parent[x];
        }

        union(x, y) {
            const px = this.find(x);
            const py = this.find(y);
            if (px === py) return;

            if (this.rank[px] < this.rank[py]) {
                this.parent[px] = py;
                this.size[py] += this.size[px];
            } else if (this.rank[px] > this.rank[py]) {
                this.parent[py] = px;
                this.size[px] += this.size[py];
            } else {
                this.parent[py] = px;
                this.size[px] += this.size[py];
                this.rank[px]++;
            }
        }

        getComponents() {
            const components = new Map();
            for (let i = 0; i < this.parent.length; i++) {
                const root = this.find(i);
                if (!components.has(root)) components.set(root, []);
                components.get(root).push(i);
            }
            return Array.from(components.values()).sort((a, b) => b.length - a.length);
        }
    }

    function computeConnectedComponents() {
        const n = drones.length;
        const uf = new UnionFind(n);

        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                const signal = calculateSignalStrength(drones[i], drones[j]);
                if (signal > SIGNAL_LOST_THRESHOLD) {
                    uf.union(i, j);
                }
            }
        }

        const components = uf.getComponents();
        const giant = components[0] || [];
        const isolated = components.filter(c => c.length === 1).length;

        const giantSet = new Set(giant);
        drones.forEach((d, i) => {
            d.inGiantComponent = giantSet.has(i);
        });

        return {
            numComponents: components.length,
            giantSize: giant.length,
            isolated,
            components
        };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    TRIT SYSTEM (Hybrid Ternary Layer)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Convert continuous field state to trit
    function stateToTrit(s) {
        if (s > TRIT_THRESHOLD_POS) return TRIT.POS;
        if (s < TRIT_THRESHOLD_NEG) return TRIT.NEG;
        return TRIT.ZERO;
    }

    // Compress state to trit + magnitude (5 bits vs 64 bits)
    function compressTritState(s) {
        const trit = stateToTrit(s);
        const magnitude = Math.min(7, Math.floor(Math.abs(s) * 5));  // 3 bits
        return { trit, magnitude };
    }

    // Compute vote for a drone based on state and neighbors
    function computeTritVote(drone) {
        if (!features.trit) return TRIT.ZERO;

        // Base vote from continuous state
        let vote = stateToTrit(drone.s);

        // Neighbor influence
        const neighbors = drones.filter(d =>
            d.id !== drone.id && !d.isFaulty &&
            drone.signalStrengths && drone.signalStrengths[d.id] > SIGNAL_LOST_THRESHOLD
        );

        if (neighbors.length > 0) {
            let neighborSum = 0;
            let weightSum = 0;

            neighbors.forEach(n => {
                const w = drone.signalStrengths[n.id] || 0;
                neighborSum += (n.vote || 0) * w;
                weightSum += w;
            });

            if (weightSum > 0) {
                const neighborAvg = neighborSum / weightSum;
                const blended = VOTE_INERTIA * vote + TRIT_NEIGHBOR_INFLUENCE * neighborAvg;

                // Re-quantize
                if (blended > 0.3) vote = TRIT.POS;
                else if (blended < -0.3) vote = TRIT.NEG;
                else vote = TRIT.ZERO;
            }
        }

        // Trit wave override
        if (drone.tritWaveInfluence !== undefined && drone.tritWaveInfluence !== 0) {
            vote = drone.tritWaveInfluence;
            drone.tritWaveInfluence = 0;
        }

        return vote;
    }

    // Compute swarm consensus
    function computeTritConsensus() {
        if (!features.trit) return { pos: 0, zero: drones.length, neg: 0, result: 'disabled', winner: TRIT.ZERO, margin: 0, entropy: 0 };

        const votes = drones.filter(d => !d.isFaulty && !d.isDetached).map(d => d.vote || TRIT.ZERO);
        const pos = votes.filter(v => v === TRIT.POS).length;
        const zero = votes.filter(v => v === TRIT.ZERO).length;
        const neg = votes.filter(v => v === TRIT.NEG).length;
        const total = votes.length || 1;

        const threshold = CONSENSUS_THRESHOLD_DEFAULT;

        let result = 'split';
        let winner = TRIT.ZERO;
        let margin = 0;

        if (pos / total >= threshold) {
            result = 'consensus';
            winner = TRIT.POS;
            margin = pos / total;
        } else if (neg / total >= threshold) {
            result = 'consensus';
            winner = TRIT.NEG;
            margin = neg / total;
        } else if (zero / total >= threshold) {
            result = 'consensus';
            winner = TRIT.ZERO;
            margin = zero / total;
        } else {
            const maxDiff = Math.max(pos, zero, neg) - Math.min(pos, zero, neg);
            if (maxDiff < total * 0.1) {
                result = 'deadlock';
            }
            margin = Math.max(pos, zero, neg) / total;
        }

        // Entropy
        const probs = [pos/total, zero/total, neg/total].filter(x => x > 0);
        const entropy = probs.length > 0 ? -probs.reduce((s, p) => s + p * Math.log2(p), 0) / Math.log2(3) : 0;

        return { pos, zero, neg, result, winner, margin, entropy, total };
    }

    // Send trit wave from base
    function sendTritWave(forceValue = null) {
        if (!features.trit) return;

        const consensus = computeTritConsensus();
        tritWaveValue = forceValue !== null ? forceValue : consensus.winner;

        tritWaveActive = true;
        tritWaveOrigin = { x: base.x, y: base.y };
        tritWaveRadius = 0;

        log(`üî∫ Trit wave: ${tritWaveValue > 0 ? '+1' : tritWaveValue < 0 ? '-1' : '0'}`, 'trit');
    }

    // Update trit wave propagation
    function updateTritWave() {
        if (!tritWaveActive || !features.trit) return;

        tritWaveRadius += TRIT_WAVE_SPEED;

        const size = Math.sqrt(parseInt(document.getElementById('swarm-size').value));

        drones.forEach(d => {
            if (d.isFaulty || d.isDetached) return;

            const dist = Math.sqrt(Math.pow(d.x - tritWaveOrigin.x, 2) + Math.pow(d.y - tritWaveOrigin.y, 2));

            if (dist >= tritWaveRadius - TRIT_WAVE_WIDTH && dist <= tritWaveRadius + TRIT_WAVE_WIDTH) {
                d.tritWaveInfluence = tritWaveValue;
                d.inTritWaveFront = true;
            } else {
                d.inTritWaveFront = false;
            }
        });

        if (tritWaveRadius > size * 1.5) {
            tritWaveActive = false;
            log(`üî∫ Trit wave complete`, 'trit');
        }
    }

    // Ternary fault status (+1 healthy, 0 uncertain, -1 faulty)
    function computeTernaryFaultStatus(drone) {
        if (drone.isFaulty) return TRIT.NEG;

        const signalHealth = drone.avgSignal || 0;
        const stateStable = Math.abs((drone.s || 0) - (drone.prevS || 0)) < 0.1;

        // Check neighbor agreement
        const neighbors = drones.filter(d =>
            d.id !== drone.id && !d.isFaulty &&
            drone.signalStrengths && drone.signalStrengths[d.id] > SIGNAL_LOST_THRESHOLD
        );

        let agreement = 0;
        if (neighbors.length > 0) {
            const avgNeighborState = neighbors.reduce((s, n) => s + (n.s || 0), 0) / neighbors.length;
            agreement = 1 - Math.min(1, Math.abs((drone.s || 0) - avgNeighborState));
        }

        const healthScore = signalHealth * 0.4 + (stateStable ? 0.3 : 0) + agreement * 0.3;

        if (healthScore > 0.7) return TRIT.POS;
        if (healthScore < 0.3) return TRIT.NEG;
        return TRIT.ZERO;
    }

    // Track trit transitions
    function trackTritTransition(prevVote, newVote) {
        if (prevVote === newVote) return;

        tritTransitions.total++;
        if (prevVote === TRIT.POS && newVote === TRIT.ZERO) tritTransitions.posToZero++;
        else if (prevVote === TRIT.ZERO && newVote === TRIT.NEG) tritTransitions.zeroToNeg++;
        else if (prevVote === TRIT.NEG && newVote === TRIT.POS) tritTransitions.negToPos++;
    }

    // Inject votes into subset of drones
    function injectTritVote(value) {
        if (!features.trit) return;

        const count = Math.floor(drones.length * 0.3);
        const candidates = drones.filter(d => !d.isFaulty && !d.isDetached);
        const shuffled = [...candidates].sort(() => seededRandom() - 0.5);

        shuffled.slice(0, count).forEach(d => {
            d.s = value * 0.5;
            d.vote = value;
        });

        log(`üó≥Ô∏è Injected vote ${value > 0 ? '+1' : value < 0 ? '-1' : '0'} into ${count} drones`, 'vote');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    LIMINAL / COMPRESSION MODE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Decompress trit state back to continuous value
    function decompressState(compressed) {
        if (!compressed) return 0;
        const sign = compressed.trit;
        const magnitude = compressed.magnitude / 5;  // Reverse the compression
        return sign * magnitude;
    }

    // Check if conditions warrant entering liminal mode
    function shouldEnterLiminal(consensus) {
        if (!features.trit || liminalMode) return false;

        const n = drones.filter(d => !d.isFaulty && !d.isDetached).length;
        const flipRate = cycle > 0 ? (tritTransitions.total / cycle / Math.max(1, n)) : 0;

        return (
            consensus.entropy > LIMINAL_TRIGGER_ENTROPY &&
            flipRate > LIMINAL_TRIGGER_FLIPRATE
        );
    }

    // Enter liminal compression mode
    function enterLiminalMode() {
        liminalMode = true;
        liminalCycles = 0;
        totalLiminalEvents++;
        log('üåÄ ENTER LIMINAL MODE ‚Äî Compression gate engaged', 'fault');

        // Add to detected events if dashboard exists
        if (typeof addDetectedEvent === 'function') {
            addDetectedEvent('warning', 'Liminal compression engaged');
        }
    }

    // Exit liminal mode
    function exitLiminalMode() {
        liminalMode = false;
        log('üß† EXIT LIMINAL MODE ‚Äî Reintegration complete', 'trit');

        if (typeof addDetectedEvent === 'function') {
            addDetectedEvent('success', `Liminal exit after ${liminalCycles} cycles`);
        }
    }

    // Process liminal mode effects
    function processLiminalMode() {
        if (!liminalMode) return;

        liminalCycles++;

        // Temporarily boost beta (reduce noise influence) and force compression fidelity
        drones.forEach(d => {
            if (d.isFaulty || d.isDetached) return;

            // Boost beta toward stability
            d.beta = Math.min(0.97, d.beta + LIMINAL_BETA_BOOST);

            // Force state to match compressed representation (lossy sync)
            if (d.compressed) {
                const decompressed = decompressState(d.compressed);
                d.s = d.s * 0.7 + decompressed * 0.3;  // Blend toward compressed value
            }
        });

        // Exit after max cycles
        if (liminalCycles >= LIMINAL_MAX_CYCLES) {
            exitLiminalMode();
        }
    }

    // Check and potentially enter liminal mode
    function checkLiminalTrigger() {
        if (!features.trit) return;

        const consensus = computeTritConsensus();

        if (shouldEnterLiminal(consensus)) {
            enterLiminalMode();
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //              CONTEXTUAL EPISTEMIC GOVERNANCE (CEG)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Gather all metrics used for CEG decisions
    function getCEGMetrics() {
        const activeDrones = drones.filter(d => !d.isFaulty && !d.isDetached);
        const n = activeDrones.length;
        const faultRatio = faults.length / drones.length;
        const coherence = computeOrderParameter().coherence;

        // Compute entropy and flip rate from trit system
        let entropy = 0;
        let flipRate = 0;
        if (features.trit) {
            const consensus = computeTritConsensus();
            entropy = consensus.entropy;
            flipRate = cycle > 0 ? (tritTransitions.total / cycle / Math.max(1, n)) : 0;
        }

        // Cascading pressure
        const cascading = drones.filter(d => d.isCascading).length / drones.length;

        // Signal stability (variance in states)
        const avgState = activeDrones.reduce((s, d) => s + d.s, 0) / Math.max(1, n);
        const stateVariance = activeDrones.reduce((s, d) => s + Math.pow(d.s - avgState, 2), 0) / Math.max(1, n);

        return {
            entropy,
            flipRate,
            faultRatio,
            coherence,
            cascading,
            stateVariance,
            activeDrones: n,
            inLiminal: liminalMode
        };
    }

    // Determine the recommended governance mode based on metrics
    function evaluateCEGMode(metrics) {
        // EMG: Emergency takes priority - severe fault state
        if (metrics.faultRatio > CEG_FAULT_THRESHOLD) {
            return { mode: CEG_MODE.EMG, reason: `Faults ${(metrics.faultRatio * 100).toFixed(0)}% > ${CEG_FAULT_THRESHOLD * 100}%` };
        }

        // EMG: Signal collapse
        if (metrics.coherence < CEG_SIGNAL_COLLAPSE && metrics.cascading > 0.15) {
            return { mode: CEG_MODE.EMG, reason: `Coherence collapse ${metrics.coherence.toFixed(2)} + cascade` };
        }

        // SEN: Sentinel mode for high entropy/instability
        if (metrics.entropy > CEG_ENTROPY_HIGH || metrics.flipRate > CEG_FLIPRATE_HIGH) {
            return { mode: CEG_MODE.SEN, reason: `High entropy ${metrics.entropy.toFixed(2)} / flip ${metrics.flipRate.toFixed(3)}` };
        }

        // EPI: Epistemic mode for moderate complexity (experts help)
        if (metrics.entropy > CEG_ENTROPY_MID && metrics.entropy <= CEG_ENTROPY_HIGH) {
            if (metrics.flipRate < CEG_FLIPRATE_HIGH) {
                return { mode: CEG_MODE.EPI, reason: `Moderate entropy ${metrics.entropy.toFixed(2)}, stable voting` };
            }
        }

        // EPI: Also for low coherence but manageable conditions
        if (metrics.coherence < 0.5 && metrics.faultRatio < 0.15 && !metrics.inLiminal) {
            return { mode: CEG_MODE.EPI, reason: `Low coherence ${metrics.coherence.toFixed(2)}, need expertise` };
        }

        // DEM: Default democratic mode for stable conditions
        if (metrics.entropy < CEG_ENTROPY_LOW && metrics.flipRate < CEG_FLIPRATE_LOW) {
            return { mode: CEG_MODE.DEM, reason: `Stable: entropy ${metrics.entropy.toFixed(2)}, flip ${metrics.flipRate.toFixed(3)}` };
        }

        // Stay in current mode if no clear transition
        return { mode: cegMode, reason: 'No transition criteria met' };
    }

    // Execute mode transition with logging
    function transitionCEGMode(newMode, reason) {
        const oldMode = cegMode;

        // Record history
        if (cegModeHistory.length > 0) {
            cegModeHistory[cegModeHistory.length - 1].endCycle = cycle;
        }
        cegModeHistory.push({
            mode: newMode,
            startCycle: cycle,
            endCycle: null,
            reason: reason,
            fromMode: oldMode
        });
        if (cegModeHistory.length > MAX_CEG_HISTORY) cegModeHistory.shift();

        // Log transition
        const modeEmoji = { DEM: 'üó≥Ô∏è', EPI: 'üéì', SEN: 'üõ°Ô∏è', EMG: 'üö®' };
        log(`${modeEmoji[newMode]} CEG ‚Üí ${CEG_LABELS[newMode]}: ${reason}`,
            newMode === CEG_MODE.EMG ? 'fault' : newMode === CEG_MODE.SEN ? 'warning' : 'trit');

        // Dashboard event
        if (typeof addDetectedEvent === 'function') {
            const eventType = newMode === CEG_MODE.EMG ? 'critical' :
                              newMode === CEG_MODE.SEN ? 'warning' : 'success';
            addDetectedEvent(eventType, `CEG: ${oldMode} ‚Üí ${newMode}`);
        }

        cegMode = newMode;
        cegCyclesInMode = 0;
        cegPendingMode = null;
        cegPendingCycles = 0;
        totalModeTransitions++;

        // Apply new mode parameters immediately
        applyGovernanceMode();

        // SEN mode delegates to liminal if not already active
        if (newMode === CEG_MODE.SEN && !liminalMode && features.trit) {
            enterLiminalMode();
        }
    }

    // Apply mode-specific parameters to effective values
    function applyGovernanceMode() {
        cegEffectiveBeta = CEG_BETA_MODS[cegMode];
        cegEffectiveCoupling = CEG_COUPLING_MODS[cegMode];
        cegEffectiveConsensus = CEG_CONSENSUS_THRESH[cegMode];
    }

    // Compute epistemic weight for a drone (only used in EPI mode)
    function computeEpistemicWeight(drone) {
        if (cegMode !== CEG_MODE.EPI) return 1.0;

        let weight = 1.0;

        // Ganglion bonus
        if (drone.isGanglion) {
            weight *= EPI_GANGLION_WEIGHT;
        }

        // Stability bonus (low personal flip rate)
        const personalFlips = drone.voteFlips || 0;
        const personalFlipRate = cycle > 10 ? personalFlips / cycle : 0;
        const stabilityBonus = Math.max(0, EPI_STABILITY_WEIGHT * (1 - personalFlipRate / 0.1));
        weight += stabilityBonus;

        // Track record (accuracy over time - starts neutral)
        const trackRecord = drone.epistemicTrackRecord || 0.5;
        weight *= (0.7 + trackRecord * 0.6);  // Range: 0.7 to 1.3

        // Zooid role bonus
        if (drone.zooidType === 'gastrozooid') {
            weight *= 1.1;  // Sensors get slight boost
        }

        return Math.max(0.3, Math.min(2.5, weight));  // Clamp to reasonable range
    }

    // Compute weighted consensus (for EPI mode)
    function computeWeightedConsensus() {
        if (cegMode !== CEG_MODE.EPI) {
            return computeTritConsensus();  // Fall back to standard
        }

        const activeDrones = drones.filter(d => !d.isFaulty && !d.isDetached);
        let weightedPos = 0, weightedZero = 0, weightedNeg = 0;
        let totalWeight = 0;

        activeDrones.forEach(d => {
            const weight = computeEpistemicWeight(d);
            totalWeight += weight;

            if (d.vote === 1) weightedPos += weight;
            else if (d.vote === -1) weightedNeg += weight;
            else weightedZero += weight;
        });

        if (totalWeight === 0) {
            return computeTritConsensus();
        }

        const posRatio = weightedPos / totalWeight;
        const zeroRatio = weightedZero / totalWeight;
        const negRatio = weightedNeg / totalWeight;

        // Determine consensus with effective threshold
        let result = 'none';
        let winner = TRIT.ZERO;
        let margin = 0;

        if (posRatio >= cegEffectiveConsensus) {
            result = 'consensus';
            winner = TRIT.POS;
            margin = posRatio - Math.max(zeroRatio, negRatio);
        } else if (negRatio >= cegEffectiveConsensus) {
            result = 'consensus';
            winner = TRIT.NEG;
            margin = negRatio - Math.max(zeroRatio, posRatio);
        } else if (Math.abs(posRatio - negRatio) < 0.05 && posRatio > 0.3 && negRatio > 0.3) {
            result = 'deadlock';
            margin = 0;
        }

        // Entropy calculation
        const probs = [posRatio, zeroRatio, negRatio].filter(p => p > 0);
        const entropy = -probs.reduce((s, p) => s + p * Math.log2(p), 0) / Math.log2(3);

        return {
            pos: Math.round(weightedPos),
            zero: Math.round(weightedZero),
            neg: Math.round(weightedNeg),
            total: totalWeight,
            result,
            winner,
            margin,
            entropy,
            weighted: true
        };
    }

    // Update epistemic track records based on consensus outcomes
    function updateEpistemicTrackRecords(consensus) {
        if (!consensus || consensus.result !== 'consensus') return;

        drones.forEach(d => {
            if (d.isFaulty || d.isDetached) return;

            // Initialize track record if needed
            if (d.epistemicTrackRecord === undefined) {
                d.epistemicTrackRecord = 0.5;
            }

            // Did this drone agree with consensus?
            const agreedWithConsensus = d.vote === consensus.winner;

            // Update track record with decay
            const adjustment = agreedWithConsensus ? 0.02 : -0.01;
            d.epistemicTrackRecord = d.epistemicTrackRecord * EPI_TRACK_RECORD_DECAY +
                                     (1 - EPI_TRACK_RECORD_DECAY) * (agreedWithConsensus ? 1 : 0);
            d.epistemicTrackRecord = Math.max(0.1, Math.min(0.9, d.epistemicTrackRecord));
        });
    }

    // Main CEG update function - called each cycle
    function updateCEG() {
        if (!features.trit) return;

        cegCyclesInMode++;

        // Get current metrics
        const metrics = getCEGMetrics();

        // Evaluate recommended mode
        const recommendation = evaluateCEGMode(metrics);

        // Handle hysteresis - don't flap between modes
        if (recommendation.mode !== cegMode) {
            // Emergency always transitions immediately
            if (recommendation.mode === CEG_MODE.EMG) {
                transitionCEGMode(CEG_MODE.EMG, recommendation.reason);
                return;
            }

            // Other modes need hysteresis
            if (cegCyclesInMode < CEG_HYSTERESIS_CYCLES) {
                // Too soon to switch, ignore recommendation
                return;
            }

            // Start or continue pending transition
            if (cegPendingMode === recommendation.mode) {
                cegPendingCycles++;
                if (cegPendingCycles >= CEG_STABILITY_WINDOW) {
                    // Confirmed - execute transition
                    transitionCEGMode(recommendation.mode, recommendation.reason);
                }
            } else {
                // New pending mode
                cegPendingMode = recommendation.mode;
                cegPendingCycles = 1;
            }
        } else {
            // Staying in current mode - reset pending
            cegPendingMode = null;
            cegPendingCycles = 0;
        }

        // Update track records if we had a consensus this cycle
        if (cegMode === CEG_MODE.EPI) {
            const consensus = computeWeightedConsensus();
            updateEpistemicTrackRecords(consensus);
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    PREDICTIVE MODE SELECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Record current metrics for trend analysis
    function recordMetricHistory(metrics) {
        metricHistory.entropy.push(metrics.entropy);
        metricHistory.flipRate.push(metrics.flipRate);
        metricHistory.coherence.push(metrics.coherence);
        metricHistory.faults.push(metrics.faultRatio);

        // Keep only PREDICT_WINDOW entries
        Object.keys(metricHistory).forEach(key => {
            if (metricHistory[key].length > PREDICT_WINDOW) {
                metricHistory[key].shift();
            }
        });
    }

    // Compute velocity (rate of change) of a metric
    function computeMetricVelocity(history) {
        if (history.length < 3) return 0;
        const recent = history.slice(-3);
        return (recent[2] - recent[0]) / 2;
    }

    // Compute acceleration (rate of velocity change)
    function computeMetricAcceleration(history) {
        if (history.length < 5) return 0;
        const v1 = (history[history.length - 3] - history[history.length - 5]) / 2;
        const v2 = (history[history.length - 1] - history[history.length - 3]) / 2;
        return v2 - v1;
    }

    // Project metric value forward
    function projectMetric(history, lookahead) {
        if (history.length < 3) return history[history.length - 1] || 0;
        const velocity = computeMetricVelocity(history);
        const current = history[history.length - 1];
        return current + velocity * lookahead;
    }

    // Analyze trends and predict future mode needs
    function predictFutureMode() {
        if (metricHistory.entropy.length < PREDICT_WINDOW / 2) {
            return { mode: null, confidence: 0, reason: 'Insufficient history' };
        }

        const entropyVel = computeMetricVelocity(metricHistory.entropy);
        const flipRateAccel = computeMetricAcceleration(metricHistory.flipRate);
        const coherenceVel = computeMetricVelocity(metricHistory.coherence);

        // Project forward
        const projectedEntropy = projectMetric(metricHistory.entropy, PREDICT_LOOKAHEAD);
        const projectedFlipRate = projectMetric(metricHistory.flipRate, PREDICT_LOOKAHEAD);
        const projectedCoherence = projectMetric(metricHistory.coherence, PREDICT_LOOKAHEAD);

        let predictedMode = null;
        let confidence = 0;
        let reason = '';

        // Check for impending crisis (entropy rising fast toward SEN threshold)
        if (entropyVel > PREDICT_ENTROPY_VELOCITY && projectedEntropy > CEG_ENTROPY_HIGH) {
            predictedMode = CEG_MODE.SEN;
            confidence = Math.min(1, entropyVel / PREDICT_ENTROPY_VELOCITY * 0.5 + 0.3);
            reason = `Entropy rising ${entropyVel.toFixed(3)}/cycle ‚Üí ${projectedEntropy.toFixed(2)}`;
        }
        // Check for flip rate acceleration (voting instability building)
        else if (flipRateAccel > PREDICT_FLIPRATE_ACCEL && projectedFlipRate > CEG_FLIPRATE_HIGH) {
            predictedMode = CEG_MODE.SEN;
            confidence = Math.min(1, flipRateAccel / PREDICT_FLIPRATE_ACCEL * 0.4 + 0.3);
            reason = `Flip rate accelerating ‚Üí ${projectedFlipRate.toFixed(3)}`;
        }
        // Check for coherence decline suggesting EPI would help
        else if (coherenceVel < -0.02 && projectedCoherence < 0.5 && cegMode === CEG_MODE.DEM) {
            predictedMode = CEG_MODE.EPI;
            confidence = Math.min(1, Math.abs(coherenceVel) * 10 + 0.2);
            reason = `Coherence declining ‚Üí ${projectedCoherence.toFixed(2)}`;
        }
        // Check for stabilization allowing return to DEM
        else if (entropyVel < -0.01 && projectedEntropy < CEG_ENTROPY_LOW && cegMode !== CEG_MODE.DEM) {
            predictedMode = CEG_MODE.DEM;
            confidence = Math.min(1, Math.abs(entropyVel) * 15 + 0.3);
            reason = `Stabilizing ‚Üí entropy ${projectedEntropy.toFixed(2)}`;
        }

        return { mode: predictedMode, confidence, reason };
    }

    // Execute preemptive mode transition
    function executePreemptiveTransition(prediction) {
        if (!prediction.mode || prediction.confidence < PREDICT_CONFIDENCE_THRESH) return false;
        if (prediction.mode === cegMode) return false;
        if (cegCyclesInMode < CEG_HYSTERESIS_CYCLES / 2) return false;  // Some hysteresis still applies

        preemptiveTransitions++;
        log(`üîÆ PREDICTIVE: ${prediction.reason}`, 'trit');
        transitionCEGMode(prediction.mode, `Predicted: ${prediction.reason}`);

        if (typeof addDetectedEvent === 'function') {
            addDetectedEvent('success', `Predictive ‚Üí ${prediction.mode}`);
        }

        return true;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    EPISTEMIC MEMORY CONSOLIDATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Start tracking a crisis episode
    function startCrisisEpisode(metrics, mode) {
        currentEpisode = {
            startCycle: cycle,
            startConditions: { ...metrics },
            mode: mode,
            peakEntropy: metrics.entropy,
            peakFaults: metrics.faultRatio,
            resolved: false
        };
    }

    // Check if current conditions match a remembered episode
    function findSimilarEpisode(metrics) {
        return epistemicMemory.find(ep => {
            const entropyDiff = Math.abs(ep.conditions.entropy - metrics.entropy);
            const faultDiff = Math.abs(ep.conditions.faultRatio - metrics.faultRatio);
            const coherenceDiff = Math.abs(ep.conditions.coherence - metrics.coherence);
            return entropyDiff < MEMORY_SIMILARITY_THRESH &&
                   faultDiff < MEMORY_SIMILARITY_THRESH &&
                   coherenceDiff < MEMORY_SIMILARITY_THRESH;
        });
    }

    // Record episode resolution
    function resolveCurrentEpisode(success) {
        if (!currentEpisode) return;

        const duration = cycle - currentEpisode.startCycle;

        epistemicMemory.push({
            conditions: currentEpisode.startConditions,
            mode: currentEpisode.mode,
            resolution: cegMode,
            cycles: duration,
            success: success,
            peakEntropy: currentEpisode.peakEntropy,
            timestamp: cycle,
            weight: 1.0
        });

        // Trim old memories
        while (epistemicMemory.length > MEMORY_MAX_EPISODES) {
            epistemicMemory.shift();
        }

        // Update success rate
        const recentSuccess = epistemicMemory.slice(-10).filter(e => e.success).length;
        memorySuccessRate = recentSuccess / Math.min(10, epistemicMemory.length);

        // Boost/penalize drone track records based on outcome
        if (success) {
            drones.forEach(d => {
                if (!d.isFaulty && !d.isDetached) {
                    d.epistemicTrackRecord = Math.min(0.9, d.epistemicTrackRecord + MEMORY_SUCCESS_BONUS);
                }
            });
        } else {
            drones.forEach(d => {
                if (!d.isFaulty && !d.isDetached) {
                    d.epistemicTrackRecord = Math.max(0.1, d.epistemicTrackRecord - MEMORY_FAILURE_PENALTY);
                }
            });
        }

        log(`üìö Episode ${success ? 'resolved' : 'failed'}: ${currentEpisode.mode} ‚Üí ${cegMode} in ${duration} cycles`,
            success ? 'trit' : 'warning');

        currentEpisode = null;
    }

    // Decay old memory weights
    function decayEpistemicMemory() {
        epistemicMemory.forEach(ep => {
            ep.weight *= MEMORY_DECAY;
        });
        // Remove very faded memories
        epistemicMemory = epistemicMemory.filter(ep => ep.weight > 0.1);
    }

    // Use memory to inform mode selection
    function consultEpistemicMemory(metrics) {
        const similar = findSimilarEpisode(metrics);
        if (!similar) return null;

        memoryHits++;

        // Weight by recency and success
        const recommendation = {
            mode: similar.success ? similar.resolution : null,  // Use what worked, avoid what didn't
            confidence: similar.weight * (similar.success ? 0.8 : 0.3),
            reason: `Memory: ${similar.mode}‚Üí${similar.resolution} ${similar.success ? 'worked' : 'failed'} (${similar.cycles}c)`
        };

        return recommendation;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    EXTERNAL ORACLE SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Initialize oracle beacons
    function initOracles() {
        oracles = [];
        const size = Math.sqrt(parseInt(document.getElementById('swarm-size').value));

        for (let i = 0; i < ORACLE_COUNT; i++) {
            // Spread truth values to ensure some disagreement
            const baseAngle = (i / ORACLE_COUNT) * Math.PI * 2;
            const truthSpread = Math.sin(baseAngle) + (seededRandom() - 0.5) * 0.5;

            oracles.push({
                id: i,
                x: 1 + seededRandom() * (size - 2),
                y: 1 + seededRandom() * (size - 2),
                truthValue: Math.max(-1, Math.min(1, truthSpread)),  // Ground truth: -1 to 1
                lastBroadcast: 0,
                calibrations: 0,
                driftDirection: (seededRandom() - 0.5) * 2  // Initial drift direction
            });
        }
    }

    // Oracle broadcasts truth to nearby drones (with multi-oracle conflict handling)
    function processOracleBroadcasts() {
        if (oracles.length === 0) return;

        // Check if any oracles are broadcasting this cycle
        const broadcastingOracles = oracles.filter(o =>
            cycle - o.lastBroadcast >= ORACLE_BROADCAST_INTERVAL
        );

        if (broadcastingOracles.length === 0) return;

        // Mark them as having broadcast
        broadcastingOracles.forEach(o => o.lastBroadcast = cycle);

        // Process each drone
        drones.forEach(d => {
            if (d.isFaulty || d.isDetached) return;

            // Find all oracles in range of this drone
            const nearbyOracles = oracles.filter(o => {
                const dist = Math.sqrt(Math.pow(d.x - o.x, 2) + Math.pow(d.y - o.y, 2));
                return dist <= ORACLE_RANGE;
            }).map(o => ({
                ...o,
                dist: Math.sqrt(Math.pow(d.x - o.x, 2) + Math.pow(d.y - o.y, 2)),
                broadcastTruth: o.truthValue + (seededRandom() - 0.5) * ORACLE_TRUTH_VARIANCE * 2
            }));

            if (nearbyOracles.length === 0) return;

            // Handle potential conflict
            let effectiveTruth;
            if (nearbyOracles.length > 1) {
                effectiveTruth = handleOracleConflict(d, nearbyOracles);
            } else {
                effectiveTruth = nearbyOracles[0].broadcastTruth;
            }

            // Calibrate with weighted influence from all nearby oracles
            const avgInfluence = nearbyOracles.reduce((s, o) =>
                s + (1 - o.dist / ORACLE_RANGE) * ORACLE_STRENGTH, 0
            ) / nearbyOracles.length;

            calibrateDroneToOracle(d, effectiveTruth, avgInfluence);

            nearbyOracles.forEach(o => {
                const original = oracles.find(oo => oo.id === o.id);
                if (original) {
                    original.calibrations++;
                    oracleCalibrations++;
                }
            });
        });
    }

    // Calibrate a drone's epistemic track record against oracle truth
    function calibrateDroneToOracle(drone, oracleTruth, influence) {
        // How close is drone's state to oracle truth?
        const error = Math.abs(drone.s - oracleTruth);
        const accuracy = Math.max(0, 1 - error);

        // Update track record based on accuracy
        const adjustment = (accuracy - 0.5) * ORACLE_CALIBRATION_RATE * influence;
        drone.epistemicTrackRecord = Math.max(0.1, Math.min(0.9,
            drone.epistemicTrackRecord + adjustment
        ));

        // Also nudge state slightly toward truth (oracle influence on belief)
        drone.s = drone.s * (1 - influence * 0.1) + oracleTruth * influence * 0.1;
    }

    // Compute swarm-wide accuracy against oracles
    function computeOracleAccuracy() {
        if (oracles.length === 0) return 0.5;

        let totalError = 0;
        let count = 0;

        drones.forEach(d => {
            if (d.isFaulty || d.isDetached) return;

            // Find nearest oracle
            let minDist = Infinity;
            let nearestOracle = null;
            oracles.forEach(o => {
                const dist = Math.sqrt(Math.pow(d.x - o.x, 2) + Math.pow(d.y - o.y, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearestOracle = o;
                }
            });

            if (nearestOracle && minDist < ORACLE_RANGE * 2) {
                const error = Math.abs(d.s - nearestOracle.truthValue);
                totalError += error;
                count++;
            }
        });

        return count > 0 ? Math.max(0, 1 - totalError / count) : 0.5;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    MULTI-ORACLE CONSENSUS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Compute consensus value among oracles
    function computeOracleConsensus() {
        if (oracles.length < 2) {
            oracleConsensusValue = oracles.length > 0 ? oracles[0].truthValue : 0;
            oracleDisagreement = 0;
            return { consensus: oracleConsensusValue, disagreement: 0, conflicting: [] };
        }

        // Find average and variance
        const truthValues = oracles.map(o => o.truthValue);
        const avgTruth = truthValues.reduce((a, b) => a + b, 0) / truthValues.length;

        // Compute disagreement as max difference between any two oracles
        let maxDiff = 0;
        for (let i = 0; i < truthValues.length; i++) {
            for (let j = i + 1; j < truthValues.length; j++) {
                maxDiff = Math.max(maxDiff, Math.abs(truthValues[i] - truthValues[j]));
            }
        }

        oracleDisagreement = maxDiff / 2;  // Normalize to 0-1 range
        oracleConsensusValue = avgTruth;

        // Identify conflicting oracles (those far from consensus)
        const conflicting = oracles.filter(o =>
            Math.abs(o.truthValue - avgTruth) > ORACLE_DISAGREEMENT_THRESH / 2
        );

        return { consensus: avgTruth, disagreement: oracleDisagreement, conflicting };
    }

    // Handle drone receiving conflicting oracle information
    function handleOracleConflict(drone, nearbyOracles) {
        if (nearbyOracles.length < 2) return nearbyOracles[0]?.truthValue || 0;

        const truthValues = nearbyOracles.map(o => o.truthValue);
        const maxDiff = Math.max(...truthValues) - Math.min(...truthValues);

        // If significant disagreement, drone must reconcile
        if (maxDiff > ORACLE_DISAGREEMENT_THRESH) {
            oracleConflictEvents++;

            // Weight by distance (closer oracles more influential)
            let weightedTruth = 0;
            let totalWeight = 0;

            nearbyOracles.forEach(o => {
                const dist = Math.sqrt(Math.pow(drone.x - o.x, 2) + Math.pow(drone.y - o.y, 2));
                const weight = 1 / (1 + dist);

                // Consensus oracles get more weight
                const isConsensus = Math.abs(o.truthValue - oracleConsensusValue) < ORACLE_DISAGREEMENT_THRESH / 2;
                const adjustedWeight = weight * (isConsensus ? ORACLE_CONSENSUS_WEIGHT : ORACLE_MINORITY_WEIGHT);

                weightedTruth += o.truthValue * adjustedWeight;
                totalWeight += adjustedWeight;
            });

            // Conflict causes uncertainty - penalize track record slightly
            drone.epistemicTrackRecord = Math.max(0.1,
                drone.epistemicTrackRecord - ORACLE_CONFLICT_PENALTY * 0.1
            );

            return totalWeight > 0 ? weightedTruth / totalWeight : 0;
        }

        // No significant conflict - use average
        return truthValues.reduce((a, b) => a + b, 0) / truthValues.length;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    TEMPORAL ORACLE DRIFT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Update oracle drift directions and values
    function updateOracleDrift() {
        oracles.forEach(oracle => {
            // Initialize drift direction if needed
            if (oracle.driftDirection === undefined) {
                oracle.driftDirection = (seededRandom() - 0.5) * 2;  // -1 to 1
            }

            // Chance of drift reversal
            if (seededRandom() < ORACLE_DRIFT_REVERSAL) {
                oracle.driftDirection *= -1;
                driftReversals++;
                log(`‚ö° Oracle ${oracle.id} drift reversed`, 'warning');
            }

            // Apply drift with variance
            const driftAmount = ORACLE_DRIFT_RATE * oracle.driftDirection +
                               (seededRandom() - 0.5) * ORACLE_DRIFT_VARIANCE;

            const oldTruth = oracle.truthValue;
            oracle.truthValue += driftAmount;

            // Bound truth value
            oracle.truthValue = Math.max(-ORACLE_TRUTH_BOUNDS,
                               Math.min(ORACLE_TRUTH_BOUNDS, oracle.truthValue));

            // Track total drift
            totalOracleDrift += Math.abs(oracle.truthValue - oldTruth);

            // If hitting bounds, reverse drift
            if (Math.abs(oracle.truthValue) >= ORACLE_TRUTH_BOUNDS * 0.95) {
                oracle.driftDirection *= -0.8;  // Bounce back with some dampening
            }
        });
    }

    // Get drift status for display
    function getOracleDriftStatus() {
        if (oracles.length === 0) return { rate: 0, direction: 'stable' };

        const avgDrift = oracles.reduce((s, o) => s + o.driftDirection, 0) / oracles.length;
        let direction = 'stable';
        if (avgDrift > 0.3) direction = 'positive';
        else if (avgDrift < -0.3) direction = 'negative';
        else if (Math.abs(avgDrift) > 0.1) direction = 'mixed';

        return {
            rate: totalOracleDrift / Math.max(1, cycle),
            direction,
            reversals: driftReversals
        };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    CROSS-SWARM MEMORY SHARING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Select top episodes to share
    function selectEpisodesToShare() {
        if (epistemicMemory.length === 0) return [];

        // Sort by success and recency
        const sorted = [...epistemicMemory]
            .filter(ep => ep.success)  // Only share successes
            .sort((a, b) => {
                // Prioritize: recent, successful, fast resolution
                const scoreA = a.weight * (a.success ? 2 : 0.5) * (1 / Math.max(1, a.cycles / 50));
                const scoreB = b.weight * (b.success ? 2 : 0.5) * (1 / Math.max(1, b.cycles / 50));
                return scoreB - scoreA;
            });

        return sorted.slice(0, MEMORY_SHARE_COUNT);
    }

    // Broadcast memories to shared pool (simulates cross-swarm communication)
    function broadcastMemories() {
        if (cycle - lastMemoryShare < MEMORY_SHARE_INTERVAL) return;
        lastMemoryShare = cycle;

        const toShare = selectEpisodesToShare();
        if (toShare.length === 0) return;

        memoryGenerations++;

        toShare.forEach(episode => {
            // Check if similar episode already in shared pool
            const exists = sharedMemoryPool.find(sm =>
                Math.abs(sm.episode.conditions.entropy - episode.conditions.entropy) < MEMORY_SIMILARITY_THRESH &&
                sm.episode.mode === episode.mode
            );

            if (!exists) {
                sharedMemoryPool.push({
                    episode: { ...episode },
                    source: 'local',
                    generation: memoryGenerations,
                    weight: episode.weight * MEMORY_INHERITANCE_WEIGHT
                });
            }
        });

        // Trim pool
        while (sharedMemoryPool.length > SHARED_MEMORY_POOL_SIZE) {
            // Remove oldest/weakest
            sharedMemoryPool.sort((a, b) => b.weight - a.weight);
            sharedMemoryPool.pop();
        }

        if (toShare.length > 0) {
            log(`üì° Broadcast ${toShare.length} memories to shared pool (gen ${memoryGenerations})`, 'trit');
        }
    }

    // Inherit memories from shared pool
    function inheritSharedMemories() {
        if (sharedMemoryPool.length === 0) return;

        // Decay shared memories
        sharedMemoryPool.forEach(sm => {
            sm.weight *= MEMORY_GENERATION_DECAY;
        });

        // Remove very faded shared memories
        sharedMemoryPool = sharedMemoryPool.filter(sm => sm.weight > 0.1);

        // Check if any shared memory is relevant to current conditions
        const metrics = getCEGMetrics();
        const relevantShared = sharedMemoryPool.find(sm => {
            const ep = sm.episode;
            return Math.abs(ep.conditions.entropy - metrics.entropy) < MEMORY_SIMILARITY_THRESH * 1.5 &&
                   Math.abs(ep.conditions.faultRatio - metrics.faultRatio) < MEMORY_SIMILARITY_THRESH * 1.5;
        });

        if (relevantShared && !findSimilarEpisode(metrics)) {
            // Inherit this memory
            memoryInheritanceCount++;

            // Add to local memory with reduced weight
            epistemicMemory.push({
                ...relevantShared.episode,
                weight: relevantShared.weight * MEMORY_INHERITANCE_WEIGHT,
                inherited: true,
                generation: relevantShared.generation
            });

            log(`üì• Inherited memory: ${relevantShared.episode.mode}‚Üí${relevantShared.episode.resolution} (gen ${relevantShared.generation})`, 'trit');

            // Boost drone track records slightly from inherited wisdom
            drones.forEach(d => {
                if (!d.isFaulty && !d.isDetached) {
                    d.epistemicTrackRecord = Math.min(0.9,
                        d.epistemicTrackRecord + 0.01
                    );
                }
            });
        }
    }

    // Get shared memory stats
    function getSharedMemoryStats() {
        return {
            poolSize: sharedMemoryPool.length,
            generations: memoryGenerations,
            inheritances: memoryInheritanceCount,
            avgWeight: sharedMemoryPool.length > 0 ?
                sharedMemoryPool.reduce((s, m) => s + m.weight, 0) / sharedMemoryPool.length : 0
        };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    INTEGRATED ADVANCED CEG
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Main update function integrating all three systems
    function updateAdvancedCEG() {
        if (!features.trit) return;

        const metrics = getCEGMetrics();

        // 1. Record history for prediction
        recordMetricHistory(metrics);

        // 2. Update current episode tracking
        if (currentEpisode) {
            currentEpisode.peakEntropy = Math.max(currentEpisode.peakEntropy, metrics.entropy);
            currentEpisode.peakFaults = Math.max(currentEpisode.peakFaults, metrics.faultRatio);

            // Check for resolution (returned to stable state)
            if (metrics.entropy < CEG_ENTROPY_LOW && metrics.flipRate < CEG_FLIPRATE_LOW) {
                resolveCurrentEpisode(true);
            }
            // Check for failure (got worse or timed out)
            else if (cycle - currentEpisode.startCycle > 100) {
                resolveCurrentEpisode(false);
            }
        }

        // 3. Start new episode if entering crisis
        if (!currentEpisode && (cegMode === CEG_MODE.SEN || cegMode === CEG_MODE.EMG)) {
            startCrisisEpisode(metrics, cegMode);
        }

        // 4. Try predictive mode selection
        const prediction = predictFutureMode();
        predictedMode = prediction.mode;
        predictionConfidence = prediction.confidence;

        if (executePreemptiveTransition(prediction)) {
            return;  // Preemptive transition took priority
        }

        // 5. Consult epistemic memory for guidance
        const memoryAdvice = consultEpistemicMemory(metrics);
        if (memoryAdvice && memoryAdvice.mode && memoryAdvice.confidence > 0.6) {
            // Memory suggests a mode - factor into decision
            if (memoryAdvice.mode !== cegMode && cegCyclesInMode >= CEG_HYSTERESIS_CYCLES) {
                log(`üìö Memory recommends: ${memoryAdvice.reason}`, 'trit');
            }
        }

        // 6. Process oracle broadcasts
        processOracleBroadcasts();

        // 7. Update oracle accuracy metric
        oracleAccuracy = computeOracleAccuracy();

        // 8. Compute oracle consensus (multi-oracle)
        computeOracleConsensus();

        // 9. Apply temporal oracle drift
        if (cycle % 5 === 0) {  // Drift every 5 cycles for smoothness
            updateOracleDrift();
        }

        // 10. Cross-swarm memory sharing
        broadcastMemories();
        inheritSharedMemories();

        // 11. Decay old memories
        if (cycle % 50 === 0) {
            decayEpistemicMemory();
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    ADAPTIVE NOISE SCALING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Compute adaptive noise level based on terrain, environment, and local conditions
    function getAdaptiveNoise(drone) {
        let noiseMult = 1.0;

        // Terrain-based noise
        const tx = safeMod(Math.floor(drone.x * 2), terrainSize);
        const ty = safeMod(Math.floor(drone.y * 2), terrainSize);

        if (terrain[ty] && terrain[ty][tx]) {
            const cell = terrain[ty][tx];

            // Unexplored territory = higher uncertainty
            if (!cell.explored) {
                noiseMult *= SIGMA_UNEXPLORED_MULT;
            }

            // Near obstacles = turbulent, noisy
            if (cell.type === TERRAIN.OBSTACLE) {
                noiseMult *= SIGMA_OBSTACLE_MULT;
            }
        }

        // Check adjacent cells for obstacle proximity
        let nearObstacle = false;
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const nx = safeMod(tx + dx, terrainSize);
                const ny = safeMod(ty + dy, terrainSize);
                if (terrain[ny] && terrain[ny][nx] && terrain[ny][nx].type === TERRAIN.OBSTACLE) {
                    nearObstacle = true;
                    break;
                }
            }
            if (nearObstacle) break;
        }
        if (nearObstacle) noiseMult *= 1.5;

        // Storm intensity increases noise significantly
        if (weather.stormIntensity > 0) {
            noiseMult *= 1 + (weather.stormIntensity * (SIGMA_STORM_MULT - 1));
        }

        // Neighbor density reduces noise (safety in numbers)
        const neighborCount = Object.keys(drone.signalStrengths).filter(
            id => drone.signalStrengths[id] > SIGNAL_LOST_THRESHOLD
        ).length;
        const densityFactor = Math.max(0.5, 1 - (neighborCount / 8) * SIGMA_DENSITY_REDUCTION);
        noiseMult *= densityFactor;

        // Arm coherence affects noise (stressed arms = more noise)
        if (features.arms && drone.armId !== undefined) {
            const arm = arms[drone.armId];
            if (arm && arm.coherence !== undefined) {
                // Low coherence = high noise
                const coherenceNoise = 1 + (1 - arm.coherence) * SIGMA_ARM_COHERENCE_MULT;
                noiseMult *= coherenceNoise;
            }
        }

        // Faulty neighbors increase local noise
        const faultyNearby = drones.filter(d =>
            d.isFaulty &&
            Math.abs(d.x - drone.x) < 2 &&
            Math.abs(d.y - drone.y) < 2
        ).length;
        if (faultyNearby > 0) {
            noiseMult *= 1 + (faultyNearby * 0.15);
        }

        // Temporal smoothing - blend with previous noise level
        const targetNoise = SIGMA_BASE * noiseMult;
        if (drone.adaptiveNoise === undefined) {
            drone.adaptiveNoise = targetNoise;
        } else {
            drone.adaptiveNoise = NOISE_SMOOTHING * drone.adaptiveNoise + (1 - NOISE_SMOOTHING) * targetNoise;
        }

        return drone.adaptiveNoise;
    }

    // Get swarm-wide noise statistics
    function getNoiseStats() {
        const noiseValues = drones.filter(d => !d.isFaulty && !d.isDetached)
            .map(d => d.adaptiveNoise || SIGMA_BASE);

        if (noiseValues.length === 0) return { min: 0, max: 0, avg: 0, variance: 0 };

        const min = Math.min(...noiseValues);
        const max = Math.max(...noiseValues);
        const avg = noiseValues.reduce((s, v) => s + v, 0) / noiseValues.length;
        const variance = noiseValues.reduce((s, v) => s + Math.pow(v - avg, 2), 0) / noiseValues.length;

        return { min, max, avg, variance };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    ARM NETWORK (Feature 1)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function initializeArms() {
        const armCount = parseInt(document.getElementById('arm-count').value);
        arms = [];

        // K-means-like clustering based on angle from base
        const dronesByAngle = drones.map((d, i) => {
            const angle = Math.atan2(d.y - base.y, d.x - base.x);
            return { index: i, angle: (angle + Math.PI) / (2 * Math.PI) };  // Normalize to 0-1
        });

        // Assign to arms based on angle sectors
        for (let a = 0; a < armCount; a++) {
            arms.push({
                id: a,
                drones: [],
                ganglionId: null,
                lastLocalPulse: 0,
                exploring: false,
                localState: { theta: 0, phi: 0 }  // 2D vector for arm
            });
        }

        dronesByAngle.forEach(({ index, angle }) => {
            const armIndex = Math.floor(angle * armCount) % armCount;
            arms[armIndex].drones.push(index);
            drones[index].armId = armIndex;
        });

        // Elect ganglia (highest connectivity within arm)
        arms.forEach(arm => {
            if (arm.drones.length === 0) return;

            let bestGanglion = arm.drones[0];
            let bestConnectivity = 0;

            arm.drones.forEach(di => {
                const d = drones[di];
                const connectivity = arm.drones.filter(dj =>
                    dj !== di && d.signalStrengths && d.signalStrengths[dj] > SIGNAL_LOST_THRESHOLD
                ).length;

                if (connectivity > bestConnectivity) {
                    bestConnectivity = connectivity;
                    bestGanglion = di;
                }
            });

            arm.ganglionId = bestGanglion;
            drones[bestGanglion].isGanglion = true;
        });
    }

    function reassignArms() {
        drones.forEach(d => {
            d.isGanglion = false;
            d.armId = 0;
        });
        initializeArms();
    }

    function updateArmDynamics() {
        if (!features.arms) return;

        const localPulseInterval = parseInt(document.getElementById('local-pulse-interval').value);

        arms.forEach(arm => {
            if (arm.drones.length === 0) return;

            // Calculate intra-arm coherence
            const armDrones = arm.drones.map(i => drones[i]).filter(d => !d.isFaulty);
            if (armDrones.length === 0) return;

            const mean = armDrones.reduce((s, d) => s + d.s, 0) / armDrones.length;
            const variance = armDrones.reduce((s, d) => s + Math.pow(d.s - mean, 2), 0) / armDrones.length;
            arm.coherence = 1 / (1 + variance);

            // Local pulse from ganglion if coherence drops
            if (arm.coherence < 0.7 && cycle - arm.lastLocalPulse > localPulseInterval) {
                sendLocalPulse(arm);
            }

            // Check if arm should explore (low activity, good coherence)
            arm.exploring = arm.coherence > 0.85 && seededRandom() < 0.1;
        });
    }

    function sendLocalPulse(arm) {
        const ganglion = drones[arm.ganglionId];
        if (!ganglion || ganglion.isFaulty) return;

        const strength = 0.2;

        arm.drones.forEach(di => {
            const d = drones[di];
            if (d.isFaulty) return;

            const nudge = (PULSE_ATTRACTOR - Math.abs(d.s)) * strength * 0.3;
            d.s += nudge;
            d.pulseBoost = strength * 0.05;
        });

        arm.lastLocalPulse = cycle;
        pulseStats.localPulses++;

        showLocalPulseRing(ganglion);
        log(`ü¶ë Arm ${arm.id} local pulse from G${arm.ganglionId}`, 'arm');
    }

    function showLocalPulseRing(drone) {
        const container = document.getElementById('map-container');
        const canvas = document.getElementById('map-canvas');
        const size = parseInt(document.getElementById('swarm-size').value);
        const sqrtSize = Math.sqrt(size);
        const scaleX = canvas.width / sqrtSize;
        const scaleY = canvas.height / sqrtSize;

        const ring = document.createElement('div');
        ring.className = 'pulse-ring local';
        ring.style.left = (drone.x * scaleX - 15) + 'px';
        ring.style.top = (drone.y * scaleY - 15) + 'px';
        ring.style.width = '30px';
        ring.style.height = '30px';
        container.appendChild(ring);

        setTimeout(() => ring.remove(), 800);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    SKIN SIGNALING (Feature 2)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function updateSkinStates() {
        if (!features.skin) return;

        const opticalStrength = 1 - weather.stormIntensity * 0.7;  // Reduced in dust

        drones.forEach(d => {
            if (d.isFaulty) {
                d.skinState = 'dead';
                return;
            }

            // Determine skin state based on local stress
            if (d.beta < RED_WAVE_THRESHOLD) {
                d.skinState = 'red_wave';
                d.skinIntensity = (RED_WAVE_THRESHOLD - d.beta) / (RED_WAVE_THRESHOLD - BETA_MIN);
            } else if (d.beta > BETA_BASE - 0.05) {
                d.skinState = 'blue_ring';
                d.skinIntensity = 0.5 + (d.beta - (BETA_BASE - 0.05)) * 5;
            } else {
                d.skinState = 'neutral';
                d.skinIntensity = 0.3;
            }

            // Optical channel influence on neighbors
            if (opticalStrength > 0.3) {
                drones.forEach(other => {
                    if (other.id === d.id || other.isFaulty) return;

                    const dist = Math.sqrt(Math.pow(d.x - other.x, 2) + Math.pow(d.y - other.y, 2));
                    if (dist > OPTICAL_RANGE) return;

                    const influence = (1 - dist / OPTICAL_RANGE) * opticalStrength * SKIN_INFLUENCE;

                    // Red wave: preemptively lower Œ≤
                    if (d.skinState === 'red_wave') {
                        other.skinInfluence = (other.skinInfluence || 0) - influence * d.skinIntensity;
                    }
                    // Blue ring: boost confidence
                    else if (d.skinState === 'blue_ring') {
                        other.skinInfluence = (other.skinInfluence || 0) + influence * 0.5;
                    }
                });
            }
        });
    }

    function propagateSkinWave(source, color) {
        if (!features.skin) return;

        const container = document.getElementById('map-container');
        const canvas = document.getElementById('map-canvas');
        const size = parseInt(document.getElementById('swarm-size').value);
        const sqrtSize = Math.sqrt(size);
        const scaleX = canvas.width / sqrtSize;
        const scaleY = canvas.height / sqrtSize;

        const wave = document.createElement('div');
        wave.className = 'skin-wave';
        wave.style.left = (source.x * scaleX - 8) + 'px';
        wave.style.top = (source.y * scaleY - 8) + 'px';
        wave.style.width = '16px';
        wave.style.height = '16px';
        wave.style.border = `2px solid ${color}`;
        container.appendChild(wave);

        setTimeout(() => wave.remove(), 800);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    POLARIZATION CHANNEL (New Feature 1)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function updatePolarizationChannel() {
        if (!features.arms) return;

        // Polarized iridescence - ignores dust, works arm-to-arm
        arms.forEach((arm, armIdx) => {
            if (arm.drones.length === 0) return;

            const ganglion = drones[arm.ganglionId];
            if (!ganglion || ganglion.isFaulty) return;

            // Find adjacent arms (neighboring by angle)
            const adjacentArms = [(armIdx - 1 + arms.length) % arms.length, (armIdx + 1) % arms.length];

            adjacentArms.forEach(adjIdx => {
                const adjArm = arms[adjIdx];
                if (!adjArm || adjArm.drones.length === 0) return;

                const adjGanglion = drones[adjArm.ganglionId];
                if (!adjGanglion || adjGanglion.isFaulty) return;

                // Check polarization range (ignores storm!)
                const dist = Math.sqrt(
                    Math.pow(ganglion.x - adjGanglion.x, 2) +
                    Math.pow(ganglion.y - adjGanglion.y, 2)
                );

                if (dist < POLARIZATION_RANGE) {
                    // Share arm coherence via polarized channel
                    const coherenceDiff = (arm.coherence || 0.5) - (adjArm.coherence || 0.5);

                    // Boost the weaker arm's drones
                    if (coherenceDiff > 0.1) {
                        adjArm.drones.forEach(di => {
                            const d = drones[di];
                            if (!d.isFaulty) {
                                d.polarizationBoost = (d.polarizationBoost || 0) + POLARIZATION_STRENGTH * coherenceDiff;
                            }
                        });
                    }
                }
            });
        });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    ARM AUTOTOMY & REGENERATION (New Feature 2)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function checkAutotomy() {
        if (!features.arms) return;

        arms.forEach((arm, armIdx) => {
            if (arm.drones.length === 0 || arm.isDetached) return;

            const armDrones = arm.drones.map(di => drones[di]);
            const faultyCount = armDrones.filter(d => d.isFaulty).length;
            const faultRatio = faultyCount / arm.drones.length;

            // Check autotomy conditions
            const shouldAutotomize =
                (arm.coherence !== undefined && arm.coherence < AUTOTOMY_STRESS_THRESHOLD) ||
                (faultRatio > AUTOTOMY_FAULT_RATIO);

            if (shouldAutotomize && faultyCount > 0) {
                performAutotomy(arm, armIdx, faultyCount);
            }
        });
    }

    function performAutotomy(arm, armIdx, faultyCount) {
        // Sacrifice faulty drones to prevent cascade spread
        const sacrificed = [];

        arm.drones.forEach(di => {
            const d = drones[di];
            if (d.isFaulty) {
                d.isDetached = true;
                d.detachedCycle = cycle;
                sacrificed.push(di);
            }
        });

        // Remove sacrificed from arm
        arm.drones = arm.drones.filter(di => !drones[di].isDetached);

        // Re-elect ganglion if needed
        if (sacrificed.includes(arm.ganglionId)) {
            electNewGanglion(arm);
        }

        autotomyEvents.push({ armId: armIdx, cycle, dronesLost: sacrificed.length });
        if (autotomyEvents.length > MAX_AUTOTOMY_EVENTS) autotomyEvents.shift();
        totalAutotomies++;

        // Queue regeneration
        if (regenQueue.length < MAX_REGEN_QUEUE) {
            regenQueue.push({ armId: armIdx, cycleQueued: cycle, count: Math.min(sacrificed.length, 2) });
        }

        log(`ü¶ë AUTOTOMY: Arm ${armIdx} shed ${sacrificed.length} faulty drones`, 'arm');

        // Visual effect
        sacrificed.forEach(di => {
            const d = drones[di];
            propagateSkinWave(d, '#ff6b6b');
        });
    }

    function electNewGanglion(arm) {
        if (arm.drones.length === 0) {
            arm.ganglionId = null;
            return;
        }

        let bestGanglion = arm.drones[0];
        let bestConnectivity = 0;

        arm.drones.forEach(di => {
            const d = drones[di];
            if (d.isFaulty || d.isDetached) return;

            const connectivity = arm.drones.filter(dj =>
                dj !== di && drones[dj] && !drones[dj].isFaulty &&
                d.signalStrengths && d.signalStrengths[dj] > SIGNAL_LOST_THRESHOLD
            ).length;

            if (connectivity > bestConnectivity) {
                bestConnectivity = connectivity;
                bestGanglion = di;
            }
        });

        arm.ganglionId = bestGanglion;
        if (drones[bestGanglion]) {
            drones[bestGanglion].isGanglion = true;
        }
    }

    function processRegeneration() {
        if (regenQueue.length === 0) return;

        regenQueue.forEach((regen, idx) => {
            if (seededRandom() < REGEN_RATE && regen.count > 0) {
                // Bud new drone near arm's centroid
                const arm = arms[regen.armId];
                if (!arm || arm.drones.length === 0) return;

                const armDrones = arm.drones.map(di => drones[di]).filter(d => d && !d.isDetached);
                if (armDrones.length === 0) return;

                const centroid = {
                    x: armDrones.reduce((s, d) => s + d.x, 0) / armDrones.length,
                    y: armDrones.reduce((s, d) => s + d.y, 0) / armDrones.length
                };

                // Create new drone
                const newId = drones.length;
                const newDrone = new Drone(
                    newId,
                    centroid.x + (seededRandom() - 0.5) * 0.5,
                    centroid.y + (seededRandom() - 0.5) * 0.5
                );
                newDrone.armId = regen.armId;
                newDrone.isRegenerated = true;
                newDrone.beta = BETA_BASE - 0.1;  // Slightly weaker initially

                drones.push(newDrone);
                arm.drones.push(newId);

                regen.count--;
                totalRegens++;

                log(`üå± REGEN: New drone ${newId} budded in Arm ${regen.armId}`, 'heal');
            }
        });

        // Clean up completed regenerations
        regenQueue = regenQueue.filter(r => r.count > 0);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    GIANT AXON PANIC BROADCAST (New Feature 3)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function checkPanicConditions() {
        if (cycle - lastPanicCycle < PANIC_COOLDOWN) return;

        const faultRatio = faults.length / drones.length;
        const stormPeak = weather.stormIntensity >= PANIC_STORM_THRESHOLD;

        if (faultRatio >= PANIC_FAULT_THRESHOLD || stormPeak) {
            triggerPanicBroadcast(faultRatio >= PANIC_FAULT_THRESHOLD ? 'faults' : 'storm');
        }
    }

    function triggerPanicBroadcast(reason) {
        lastPanicCycle = cycle;
        panicCount++;

        log(`‚ö° PANIC BROADCAST: ${reason} threshold exceeded!`, 'fault');

        // Instant colony-wide Œ≤ drop
        drones.forEach(d => {
            if (d.isFaulty || d.isDetached) return;
            d.beta = Math.max(BETA_MIN, d.beta - 0.2);
            d.panicState = true;
            d.axonFlash = true;
        });

        // Trigger synchronized metachronal wave
        if (features.wave) {
            const angle = seededRandom() * Math.PI * 2;
            initiateMetachronalWave(base, { x: Math.cos(angle), y: Math.sin(angle) });
        }

        // Visual flash
        const canvas = document.getElementById('map-canvas');
        canvas.style.filter = 'brightness(2.5) saturate(0.5)';
        setTimeout(() => {
            canvas.style.filter = '';
            drones.forEach(d => {
                d.axonFlash = false;
                d.panicState = false;
            });
        }, 300);

        // Show indicator
        const indicator = document.getElementById('pulse-indicator');
        indicator.textContent = '‚ö° PANIC BROADCAST';
        indicator.style.background = 'rgba(239, 68, 68, 0.5)';
        indicator.style.borderColor = '#ef4444';
        indicator.style.color = '#ef4444';
        indicator.classList.add('active');
        setTimeout(() => {
            indicator.classList.remove('active');
            indicator.style.background = '';
            indicator.style.borderColor = '';
            indicator.style.color = '';
        }, 2000);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    MYOGENIC SKIN WAVES (New Feature 4)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function updateMyogenicWaves() {
        if (!features.skin) return;

        // Process existing waves
        const newWaves = [];

        myogenicWaves.forEach(wave => {
            if (wave.intensity < 0.1) return;  // Wave died out

            const source = drones[wave.droneId];
            if (!source || source.isFaulty) return;

            // Propagate to neighbors
            drones.forEach(neighbor => {
                if (neighbor.id === source.id || neighbor.isFaulty) return;

                const dist = Math.sqrt(
                    Math.pow(source.x - neighbor.x, 2) +
                    Math.pow(source.y - neighbor.y, 2)
                );

                if (dist < OPTICAL_RANGE && seededRandom() < MYOGENIC_PROPAGATION * wave.intensity) {
                    // Check if neighbor already has this wave
                    const hasWave = myogenicWaves.some(w => w.droneId === neighbor.id && w.color === wave.color);
                    const hasNewWave = newWaves.some(w => w.droneId === neighbor.id && w.color === wave.color);

                    if (!hasWave && !hasNewWave) {
                        newWaves.push({
                            droneId: neighbor.id,
                            intensity: wave.intensity * MYOGENIC_DECAY,
                            color: wave.color,
                            cycle: cycle
                        });

                        // Apply wave effect
                        if (wave.color === 'red') {
                            neighbor.skinState = 'red_wave';
                            neighbor.skinIntensity = wave.intensity * MYOGENIC_DECAY;
                            neighbor.beta = Math.max(BETA_MIN, neighbor.beta - 0.02 * wave.intensity);
                        } else if (wave.color === 'blue') {
                            neighbor.skinState = 'blue_ring';
                            neighbor.skinIntensity = wave.intensity * MYOGENIC_DECAY;
                            neighbor.pulseBoost += 0.02 * wave.intensity;
                        }
                    }
                }
            });

            // Decay existing wave
            wave.intensity *= MYOGENIC_DECAY;
        });

        // Add new waves
        myogenicWaves.push(...newWaves);

        // Clean up dead waves
        myogenicWaves = myogenicWaves.filter(w => w.intensity >= 0.1 && cycle - w.cycle < 20);
    }

    function initiateMyogenicWave(drone, color) {
        if (!features.skin) return;

        myogenicWaves.push({
            droneId: drone.id,
            intensity: 1.0,
            color: color,
            cycle: cycle
        });

        propagateSkinWave(drone, color === 'red' ? '#ef4444' : '#22d3ee');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    HYBRID VECTOR + SKIN (New Feature 5)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function updateVectorSkinCoupling() {
        if (!features.vector || !features.skin) return;

        const vectorCoherence = computeVectorCoherence();

        drones.forEach(d => {
            if (d.isFaulty) return;

            // Calculate local vector misalignment
            const neighbors = drones.filter(n =>
                n.id !== d.id && !n.isFaulty &&
                d.signalStrengths && d.signalStrengths[n.id] > SIGNAL_LOST_THRESHOLD
            );

            if (neighbors.length === 0) return;

            // Local covariance
            const meanTheta = neighbors.reduce((s, n) => s + n.theta, d.theta) / (neighbors.length + 1);
            const meanPhi = neighbors.reduce((s, n) => s + n.phi, d.phi) / (neighbors.length + 1);

            let localCov = 0;
            [d, ...neighbors].forEach(n => {
                localCov += Math.abs((n.theta - meanTheta) * (n.phi - meanPhi));
            });
            localCov /= (neighbors.length + 1);

            // High local covariance ‚Üí red wave (misalignment stress)
            if (localCov > 0.15 && d.skinState !== 'red_wave') {
                d.skinState = 'red_wave';
                d.skinIntensity = Math.min(1, localCov * 3);

                // Initiate myogenic wave on high misalignment
                if (localCov > 0.25 && seededRandom() < 0.1) {
                    initiateMyogenicWave(d, 'red');
                }
            }
            // Low covariance + high coherence ‚Üí blue ring
            else if (localCov < 0.05 && vectorCoherence.covariance < 0.1) {
                d.skinState = 'blue_ring';
                d.skinIntensity = 0.6;

                // Occasional blue wave for coherence celebration
                if (seededRandom() < 0.02) {
                    initiateMyogenicWave(d, 'blue');
                }
            }
        });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    EUDOXID RELEASE (New Feature 6)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function checkEudoxidRelease() {
        if (!features.arms || !features.zooid) return;

        arms.forEach((arm, armIdx) => {
            if (arm.drones.length < EUDOXID_SIZE + 2) return;  // Need enough drones
            if (arm.coherence === undefined || arm.coherence < EUDOXID_SATURATION_THRESHOLD) return;

            // Check if arm already has active eudoxid
            if (eudoxids.some(e => e.armId === armIdx)) return;

            // Chance to release eudoxid
            if (seededRandom() < 0.02) {
                releaseEudoxid(arm, armIdx);
            }
        });
    }

    function releaseEudoxid(arm, armIdx) {
        // Select drones for eudoxid (prefer gastrozooids)
        const candidates = arm.drones
            .map(di => drones[di])
            .filter(d => d && !d.isFaulty && !d.isDetached && !d.inEudoxid)
            .sort((a, b) => {
                if (a.zooidType === 'gastrozooid') return -1;
                if (b.zooidType === 'gastrozooid') return 1;
                return seededRandom() - 0.5;
            });

        if (candidates.length < EUDOXID_SIZE) return;

        const eudoxidDrones = candidates.slice(0, EUDOXID_SIZE);
        const eudoxidIds = eudoxidDrones.map(d => d.id);

        // Calculate exploration target
        const size = Math.sqrt(parseInt(document.getElementById('swarm-size').value));
        const angle = seededRandom() * Math.PI * 2;
        const target = {
            x: Math.max(1, Math.min(size - 1, base.x + Math.cos(angle) * EUDOXID_RANGE)),
            y: Math.max(1, Math.min(size - 1, base.y + Math.sin(angle) * EUDOXID_RANGE))
        };

        // Mark drones as in eudoxid
        eudoxidDrones.forEach(d => {
            d.inEudoxid = true;
            d.eudoxidTarget = target;
            d.originalArmId = armIdx;
        });

        const eudoxid = {
            id: eudoxidIdCounter++,
            drones: eudoxidIds,
            origin: { x: eudoxidDrones[0].x, y: eudoxidDrones[0].y },
            target,
            birthCycle: cycle,
            armId: armIdx,
            returning: false,
            terrainRevealed: 0
        };

        eudoxids.push(eudoxid);

        log(`üî¨ EUDOXID ${eudoxid.id}: Released from Arm ${armIdx} with ${EUDOXID_SIZE} drones`, 'zooid');
    }

    function updateEudoxids() {
        eudoxids.forEach(eudoxid => {
            const age = cycle - eudoxid.birthCycle;
            const eudoxidDrones = eudoxid.drones.map(id => drones[id]).filter(d => d && !d.isFaulty);

            if (eudoxidDrones.length === 0) {
                eudoxid.dead = true;
                return;
            }

            // Determine target
            let target;
            if (age > EUDOXID_LIFESPAN / 2 || eudoxid.returning) {
                // Return to base
                eudoxid.returning = true;
                target = { x: base.x, y: base.y };
            } else {
                target = eudoxid.target;
            }

            // Move eudoxid drones toward target
            eudoxidDrones.forEach(d => {
                d.eudoxidTarget = target;

                // Enhanced exploration (gastrozooid behavior)
                const exploreRadius = 3;
                for (let dy = -exploreRadius; dy <= exploreRadius; dy++) {
                    for (let dx = -exploreRadius; dx <= exploreRadius; dx++) {
                        const tx = safeMod(Math.floor(d.x * 2) + dx, terrainSize);
                        const ty = safeMod(Math.floor(d.y * 2) + dy, terrainSize);
                        if (terrain[ty] && terrain[ty][tx] && !terrain[ty][tx].explored) {
                            terrain[ty][tx].explored = true;
                            eudoxid.terrainRevealed++;
                        }
                    }
                }
            });

            // Check if returned
            if (eudoxid.returning) {
                const centroid = {
                    x: eudoxidDrones.reduce((s, d) => s + d.x, 0) / eudoxidDrones.length,
                    y: eudoxidDrones.reduce((s, d) => s + d.y, 0) / eudoxidDrones.length
                };

                const distToBase = Math.sqrt(
                    Math.pow(centroid.x - base.x, 2) +
                    Math.pow(centroid.y - base.y, 2)
                );

                if (distToBase < 1.5) {
                    // Reintegrate into arm
                    reintegrateEudoxid(eudoxid);
                }
            }
        });

        // Clean up dead/reintegrated eudoxids
        eudoxids = eudoxids.filter(e => !e.dead && !e.reintegrated);
    }

    function reintegrateEudoxid(eudoxid) {
        const arm = arms[eudoxid.armId];

        eudoxid.drones.forEach(id => {
            const d = drones[id];
            if (d) {
                d.inEudoxid = false;
                d.eudoxidTarget = null;

                // Add back to arm if not already there
                if (arm && !arm.drones.includes(id)) {
                    arm.drones.push(id);
                }
            }
        });

        eudoxid.reintegrated = true;

        log(`üî¨ EUDOXID ${eudoxid.id}: Returned, revealed ${eudoxid.terrainRevealed} tiles`, 'zooid');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    ZOOID SPECIALIZATION (Feature 3)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function updateZooidSpecialization() {
        if (!features.zooid) {
            drones.forEach(d => d.zooidType = 'normal');
            return;
        }

        // Role election based on position and state
        drones.forEach(d => {
            if (d.isFaulty) {
                d.zooidType = 'dead';
                return;
            }

            // Keep existing specialization unless conditions change
            if (d.zooidType && d.zooidType !== 'normal' && seededRandom() > 0.02) return;

            const distToBase = Math.sqrt(Math.pow(d.x - base.x, 2) + Math.pow(d.y - base.y, 2));
            const size = Math.sqrt(parseInt(document.getElementById('swarm-size').value));
            const normalizedDist = distToBase / (size / 2);

            // Nectophores: lead movement (furthest from base with high connectivity)
            if (normalizedDist > 0.8 && d.avgSignal > 0.6 && seededRandom() < 0.15) {
                d.zooidType = 'nectophore';
            }
            // Gastrozooids: explore/sense (medium distance, in exploring arms)
            else if (normalizedDist > 0.4 && normalizedDist < 0.8 &&
                     arms[d.armId]?.exploring && seededRandom() < 0.2) {
                d.zooidType = 'gastrozooid';
            }
            // Bracts: defense (close to base or near faults)
            else if ((normalizedDist < 0.4 || d.nearFault) && seededRandom() < 0.1) {
                d.zooidType = 'bract';
            }
            else {
                d.zooidType = 'normal';
            }
        });
    }

    function applyZooidBehavior(drone) {
        if (!features.zooid) return { speedMult: 1, exploreMult: 1, faultResist: 0 };

        switch (drone.zooidType) {
            case 'nectophore':
                return { speedMult: NECTOPHORE_SPEED_MULT, exploreMult: 1, faultResist: 0 };
            case 'gastrozooid':
                return { speedMult: 0.8, exploreMult: GASTROZOOID_EXPLORE_MULT, faultResist: 0 };
            case 'bract':
                return { speedMult: 0.6, exploreMult: 0.5, faultResist: BRACT_FAULT_RESIST };
            default:
                return { speedMult: 1, exploreMult: 1, faultResist: 0 };
        }
    }

    function triggerGiantAxon() {
        // Fast pathway: colony-wide instant response
        log('‚ö° GIANT AXON: Colony-wide stress response!', 'zooid');

        drones.forEach(d => {
            if (d.isFaulty) return;
            d.beta = Math.max(BETA_MIN, d.beta - 0.15);
            d.axonFlash = true;
        });

        // Visual flash
        const canvas = document.getElementById('map-canvas');
        canvas.style.filter = 'brightness(2)';
        setTimeout(() => canvas.style.filter = '', 100);

        setTimeout(() => {
            drones.forEach(d => d.axonFlash = false);
        }, 500);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    VECTOR STATES (Feature 4)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function initVectorState(drone) {
        drone.theta = (seededRandom() - 0.5) * 0.2;  // Orientation
        drone.phi = (seededRandom() - 0.5) * 0.2;    // Sensor bias
    }

    function evolveVectorState(drone, neighbors) {
        if (!features.vector || neighbors.length === 0) return;

        // Weighted average of neighbor vectors
        let weightedTheta = 0, weightedPhi = 0, weightTotal = 0;

        neighbors.forEach(n => {
            const w = drone.signalStrengths[n.id] || 0;
            weightedTheta += n.theta * w;
            weightedPhi += n.phi * w;
            weightTotal += w;
        });

        if (weightTotal > 0) {
            const neighborAvgTheta = weightedTheta / weightTotal;
            const neighborAvgPhi = weightedPhi / weightTotal;

            // Use adaptive noise for vector state too
            const adaptiveSigma = drone.adaptiveNoise || SIGMA_BASE;
            const beta = drone.beta;
            drone.theta = beta * drone.theta + (1 - beta) * neighborAvgTheta + (seededRandom() - 0.5) * adaptiveSigma;
            drone.phi = beta * drone.phi + (1 - beta) * neighborAvgPhi + (seededRandom() - 0.5) * adaptiveSigma;

            // Storm affects phi (sensor dimension) - now integrated in adaptive noise
            drone.phi += weather.stormIntensity * (seededRandom() - 0.5) * 0.02;
        }

        // Clamp
        drone.theta = Math.max(-1.5, Math.min(1.5, drone.theta));
        drone.phi = Math.max(-1.5, Math.min(1.5, drone.phi));
    }

    function computeVectorCoherence() {
        if (!features.vector || drones.length === 0) return { meanTheta: 0, meanPhi: 0, covariance: 0 };

        const activeDrones = drones.filter(d => !d.isFaulty);
        if (activeDrones.length === 0) return { meanTheta: 0, meanPhi: 0, covariance: 0 };

        const meanTheta = activeDrones.reduce((s, d) => s + d.theta, 0) / activeDrones.length;
        const meanPhi = activeDrones.reduce((s, d) => s + d.phi, 0) / activeDrones.length;

        // Covariance
        let cov = 0;
        activeDrones.forEach(d => {
            cov += (d.theta - meanTheta) * (d.phi - meanPhi);
        });
        cov /= activeDrones.length;

        return { meanTheta, meanPhi, covariance: Math.abs(cov) };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    METACHRONAL WAVES (Feature 5)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function initiateMetachronalWave(origin, direction) {
        if (!features.wave) return;

        activeWave = {
            origin: { x: origin.x, y: origin.y },
            startCycle: cycle,
            direction: direction || { x: 1, y: 0 },
            reachedDrones: new Set()
        };

        document.getElementById('wave-indicator').style.display = 'block';
        log('üåä Metachronal wave initiated', 'wave');
    }

    function updateMetachronalWave() {
        if (!activeWave || !features.wave) return;

        const elapsed = cycle - activeWave.startCycle;
        if (elapsed > WAVE_DURATION) {
            activeWave = null;
            document.getElementById('wave-indicator').style.display = 'none';
            return;
        }

        const waveRadius = elapsed * WAVE_SPEED * 2;

        drones.forEach(d => {
            if (d.isFaulty || activeWave.reachedDrones.has(d.id)) return;

            // Calculate if wave has reached this drone
            const dx = d.x - activeWave.origin.x;
            const dy = d.y - activeWave.origin.y;
            const distFromOrigin = Math.sqrt(dx * dx + dy * dy);

            // Wave front check (within band)
            if (distFromOrigin >= waveRadius - 0.5 && distFromOrigin <= waveRadius + 0.5) {
                activeWave.reachedDrones.add(d.id);

                // Apply wave boost
                d.waveBoost = WAVE_SPEED * 3;
                d.waveDirection = { ...activeWave.direction };

                // Visual trail
                showWaveTrail(d);
            }
        });
    }

    function showWaveTrail(drone) {
        const container = document.getElementById('map-container');
        const canvas = document.getElementById('map-canvas');
        const size = parseInt(document.getElementById('swarm-size').value);
        const sqrtSize = Math.sqrt(size);
        const scaleX = canvas.width / sqrtSize;
        const scaleY = canvas.height / sqrtSize;

        const trail = document.createElement('div');
        trail.className = 'metachronal-trail';
        trail.style.left = (drone.x * scaleX) + 'px';
        trail.style.top = (drone.y * scaleY) + 'px';
        trail.style.background = '#06b6d4';
        container.appendChild(trail);

        setTimeout(() => trail.remove(), 500);
    }

    function triggerBloom() {
        bloomActive = true;
        bloomCycles = 100;
        log('üå∏ BLOOM MODE: Clustering for survival', 'wave');

        // Show visual indicators
        document.getElementById('bloom-overlay').classList.add('active');
        document.getElementById('bloom-indicator').classList.add('active');

        // All drones target base
        drones.forEach(d => {
            if (!d.isFaulty) {
                d.bloomTarget = { x: base.x, y: base.y };
            }
        });
    }

    function endBloom() {
        bloomActive = false;
        drones.forEach(d => d.bloomTarget = null);
        document.getElementById('bloom-overlay').classList.remove('active');
        document.getElementById('bloom-indicator').classList.remove('active');
        log('üå∏ Bloom mode ended', 'wave');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    SELF-HEALING (Feature 6)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function checkSelfHealing() {
        drones.forEach(d => {
            if (!d.isFaulty) return;

            // Count healthy neighbors
            const healthyNeighbors = drones.filter(other =>
                other.id !== d.id &&
                !other.isFaulty &&
                d.signalStrengths &&
                d.signalStrengths[other.id] > SIGNAL_LOST_THRESHOLD
            ).length;

            // Self-heal if enough healthy neighbors and luck
            if (healthyNeighbors >= HEAL_NEIGHBOR_THRESHOLD && seededRandom() < HEAL_PROBABILITY) {
                d.isFaulty = false;
                d.beta = BETA_BASE - 0.1;  // Partial recovery
                d.s = 0;  // Reset state
                healCount++;
                sessionStats.totalHeals++;

                log(`üíö Drone ${d.id} self-healed via neighbor support`, 'heal');

                // Remove from faults list
                const faultIndex = faults.findIndex(f => f.droneId === d.id);
                if (faultIndex >= 0) faults.splice(faultIndex, 1);
            }
        });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    BETA COMPUTATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function computeBeta(drone) {
        const mode = document.getElementById('beta-mode').value;

        if (mode === 'fixed') return BETA_BASE;
        if (drone.isFaulty) return 0;

        let beta = BETA_BASE - weather.stormIntensity * 0.2 - (1 - drone.avgSignal) * 0.15;

        // Personality variation
        beta += (drone.personality || 0);

        // Skin influence
        if (features.skin && drone.skinInfluence) {
            beta += drone.skinInfluence;
            drone.skinInfluence = 0;  // Reset
        }

        // Polarization channel boost (ignores dust storms!)
        if (drone.polarizationBoost) {
            beta += drone.polarizationBoost;
            drone.polarizationBoost = 0;  // Reset
        }

        if (mode === 'octopus' && features.arms) {
            // Octopus mode: higher Œ≤ within arm, coordinated by ganglion
            const arm = arms[drone.armId];
            if (arm) {
                // Boost for same-arm communication
                beta += ARM_LOCAL_BETA_BOOST;

                // Exploring arms lower signal threshold
                if (arm.exploring) {
                    drone.exploreMode = true;
                }
            }
        }
        else if (mode === 'predictive') {
            const neighbors = drones.filter(d =>
                d.id !== drone.id &&
                drone.signalStrengths[d.id] > SIGNAL_LOST_THRESHOLD
            );

            if (neighbors.length > 0) {
                const neighborStress = neighbors.reduce((sum, n) => {
                    return sum + (BETA_BASE - n.beta);
                }, 0) / neighbors.length;

                beta -= neighborStress * CASCADE_WEIGHT;
                drone.isCascading = neighborStress > 0.05;
            }
        }

        return Math.max(BETA_MIN, Math.min(BETA_BASE + 0.05, beta));
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    SIGNAL MODEL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function calculateSignalStrength(d1, d2) {
        const dist = Math.sqrt(Math.pow(d1.x - d2.x, 2) + Math.pow(d1.y - d2.y, 2));
        let signal = Math.exp(-dist / SIGNAL_RANGE);

        // Exploring mode: lower threshold
        if (d1.exploreMode || d2.exploreMode) {
            signal += EXPLORE_SIGNAL_BOOST;
        }

        // Terrain attenuation
        const steps = 5;
        for (let i = 1; i < steps; i++) {
            const t = i / steps;
            const x = d1.x + (d2.x - d1.x) * t;
            const y = d1.y + (d2.y - d1.y) * t;
            const tx = safeMod(Math.floor(x * 2), terrainSize);
            const ty = safeMod(Math.floor(y * 2), terrainSize);
            if (terrain[ty] && terrain[ty][tx] && terrain[ty][tx].type === TERRAIN.OBSTACLE) {
                signal *= 0.6;
            }
        }

        signal *= (1 - weather.stormIntensity * 0.5);

        return Math.max(0, Math.min(1, signal));
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    ORDER PARAMETER
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function computeOrderParameter() {
        if (drones.length === 0) return { mean: 0, variance: 0, coherence: 1 };
        const activeDrones = drones.filter(d => !d.isFaulty);
        if (activeDrones.length === 0) return { mean: 0, variance: 0, coherence: 0 };

        const mean = activeDrones.reduce((s, d) => s + d.s, 0) / activeDrones.length;
        const variance = activeDrones.reduce((s, d) => s + Math.pow(d.s - mean, 2), 0) / activeDrones.length;
        return { mean, variance, coherence: 1 / (1 + variance) };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    DRONE CLASS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    class Drone {
        constructor(id, x, y) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.targetX = x;
            this.targetY = y;

            this.s = (seededRandom() - 0.5) * 0.2;
            this.beta = BETA_BASE;
            this.pulseBoost = 0;

            // Personality variation (Feature 6)
            this.personality = (seededRandom() - 0.5) * 0.06;  // +/- 3% Œ≤ base

            this.signalStrengths = {};
            this.avgSignal = 1.0;

            this.isFaulty = false;
            this.faultCycle = null;
            this.isCascading = false;
            this.inGiantComponent = true;

            // Arm/Octopus
            this.armId = 0;
            this.isGanglion = false;
            this.exploreMode = false;

            // Skin
            this.skinState = 'neutral';
            this.skinIntensity = 0.3;
            this.skinInfluence = 0;

            // Zooid
            this.zooidType = 'normal';
            this.nearFault = false;

            // Vector state
            initVectorState(this);

            // Wave
            this.waveBoost = 0;
            this.waveDirection = null;

            // Bloom
            this.bloomTarget = null;

            // Trit system
            this.vote = TRIT.ZERO;
            this.prevVote = TRIT.ZERO;
            this.prevS = this.s;
            this.tritFaultStatus = TRIT.POS;
            this.tritWaveInfluence = 0;
            this.inTritWaveFront = false;
            this.compressed = compressTritState(this.s);

            // CEG / Epistemic tracking
            this.voteFlips = 0;
            this.epistemicTrackRecord = 0.5;  // Starts neutral
        }

        update() {
            // Track previous state for trit transitions
            this.prevS = this.s;
            this.prevVote = this.vote;

            this.updateSignals();
            this.checkNearFault();

            this.beta = computeBeta(this);

            // Apply CEG beta modifier
            const cegBetaMod = typeof cegEffectiveBeta !== 'undefined' ? cegEffectiveBeta : 0;
            const effectiveBeta = Math.min(BETA_BASE + 0.08, this.beta + this.pulseBoost + cegBetaMod);
            this.pulseBoost *= 0.9;

            this.evolve(effectiveBeta);
            this.move();

            // Update trit layer
            if (features.trit) {
                const newVote = computeTritVote(this);
                trackTritTransition(this.prevVote, newVote);

                // Track per-drone vote flips for epistemic weighting
                if (newVote !== this.prevVote && this.prevVote !== undefined) {
                    this.voteFlips = (this.voteFlips || 0) + 1;
                }

                this.vote = newVote;
                this.tritFaultStatus = computeTernaryFaultStatus(this);
                this.compressed = compressTritState(this.s);
            }

            this.exploreMode = false;
        }

        updateSignals() {
            this.signalStrengths = {};
            let total = 0, count = 0;

            drones.forEach(other => {
                if (other.id === this.id) return;
                const signal = calculateSignalStrength(this, other);
                this.signalStrengths[other.id] = signal;
                if (signal > SIGNAL_LOST_THRESHOLD) {
                    total += signal;
                    count++;
                }
            });

            this.avgSignal = count > 0 ? total / count : 0;
        }

        checkNearFault() {
            this.nearFault = drones.some(other =>
                other.isFaulty &&
                this.signalStrengths[other.id] > SIGNAL_LOST_THRESHOLD
            );
        }

        evolve(beta) {
            const neighbors = drones.filter(d =>
                d.id !== this.id &&
                !d.isFaulty &&
                this.signalStrengths[d.id] > SIGNAL_LOST_THRESHOLD
            );

            if (neighbors.length === 0) return;

            // Same-arm neighbors get extra weight in octopus mode
            // CEG coupling modifier affects neighbor influence strength
            const cegCouplingMod = typeof cegEffectiveCoupling !== 'undefined' ? cegEffectiveCoupling : 1.0;
            let weightedSum = 0, weightTotal = 0;
            neighbors.forEach(n => {
                let w = this.signalStrengths[n.id] * cegCouplingMod;
                if (features.arms && n.armId === this.armId) {
                    w *= 1.3;  // Intra-arm boost
                }
                weightedSum += n.s * w;
                weightTotal += w;
            });

            const neighborAvg = weightTotal > 0 ? weightedSum / weightTotal : 0;
            const retention = beta * this.s + (1 - beta) * neighborAvg;
            const damped = (1 - ALPHA) * retention;

            // Adaptive noise based on terrain, storm, and local conditions
            const adaptiveSigma = getAdaptiveNoise(this);
            const noise = (seededRandom() - 0.5) * adaptiveSigma * 2;

            this.s = Math.max(-1.5, Math.min(1.5, damped + noise));

            // Vector state evolution
            evolveVectorState(this, neighbors);
        }

        move() {
            const size = Math.sqrt(parseInt(document.getElementById('swarm-size').value));
            const zooidBehavior = applyZooidBehavior(this);
            let speed = 0.08 * (1 - weather.stormIntensity * 0.4) * zooidBehavior.speedMult;

            // Wave boost
            if (this.waveBoost > 0) {
                speed += this.waveBoost;
                this.waveBoost *= 0.85;

                if (this.waveDirection) {
                    this.targetX += this.waveDirection.x * 0.5;
                    this.targetY += this.waveDirection.y * 0.5;
                }
            }

            // Detached drones drift away
            if (this.isDetached) {
                const driftAngle = seededRandom() * Math.PI * 2;
                this.x += Math.cos(driftAngle) * 0.02;
                this.y += Math.sin(driftAngle) * 0.02;
                return;  // No further movement logic
            }

            // Eudoxid mode: move toward exploration target
            if (this.inEudoxid && this.eudoxidTarget) {
                this.targetX = this.eudoxidTarget.x + (seededRandom() - 0.5) * 0.5;
                this.targetY = this.eudoxidTarget.y + (seededRandom() - 0.5) * 0.5;
                speed *= 1.2;  // Eudoxids move faster
            }
            // Bloom mode: cluster toward base
            else if (bloomActive && this.bloomTarget) {
                this.targetX = this.bloomTarget.x + (seededRandom() - 0.5) * 2;
                this.targetY = this.bloomTarget.y + (seededRandom() - 0.5) * 2;
            }
            else if (seededRandom() < 0.1 * zooidBehavior.exploreMult) {
                this.targetX = this.x + (seededRandom() - 0.5) * 2;
                this.targetY = this.y + (seededRandom() - 0.5) * 2;
            }

            // Clamp targets
            this.targetX = Math.max(0.5, Math.min(size - 0.5, this.targetX));
            this.targetY = Math.max(0.5, Math.min(size - 0.5, this.targetY));

            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 0.1) {
                this.x += (dx / dist) * speed;
                this.y += (dy / dist) * speed;
            }

            // Mark terrain (gastrozooids are better)
            const exploreRadius = this.zooidType === 'gastrozooid' ? 2 : 1;
            for (let dy = -exploreRadius; dy <= exploreRadius; dy++) {
                for (let dx = -exploreRadius; dx <= exploreRadius; dx++) {
                    const tx = safeMod(Math.floor(this.x * 2) + dx, terrainSize);
                    const ty = safeMod(Math.floor(this.y * 2) + dy, terrainSize);
                    if (terrain[ty] && terrain[ty][tx]) terrain[ty][tx].explored = true;
                }
            }
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    MOBILE BASE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    class MobileBase {
        constructor(x, y) { this.x = x; this.y = y; }
        update(centroid) {
            const dx = centroid.x - this.x;
            const dy = centroid.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 2) {
                this.x += (dx / dist) * 0.03;
                this.y += (dy / dist) * 0.03;
            }
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    WEATHER
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function updateWeather() {
        if (weather.manualStorm) {
            weather.stormIntensity = Math.min(0.9, weather.stormIntensity + 0.05);
            document.getElementById('dust-overlay').style.setProperty('--dust-opacity', weather.stormIntensity * 0.4);
            return;
        }

        const stormChance = 0.003;

        switch (weather.stormPhase) {
            case 'clear':
                if (seededRandom() < stormChance || cycle >= weather.nextStormCycle) {
                    weather.stormPhase = 'approaching';
                    weather.stormDuration = 40 + seededRandom() * 80;
                }
                break;
            case 'approaching':
                weather.stormIntensity = Math.min(0.7, weather.stormIntensity + 0.02);
                if (weather.stormIntensity >= 0.5) weather.stormPhase = 'active';
                break;
            case 'active':
                weather.stormDuration--;
                weather.stormIntensity = Math.min(1, Math.max(0.3,
                    weather.stormIntensity + (seededRandom() - 0.5) * 0.05));
                if (weather.stormDuration <= 0) weather.stormPhase = 'clearing';
                break;
            case 'clearing':
                weather.stormIntensity = Math.max(0, weather.stormIntensity - 0.025);
                if (weather.stormIntensity <= 0) {
                    weather.stormPhase = 'clear';
                    weather.nextStormCycle = cycle + 100 + seededRandom() * 150;
                }
                break;
        }

        document.getElementById('dust-overlay').style.setProperty('--dust-opacity', weather.stormIntensity * 0.3);
    }

    function toggleStorm() {
        weather.manualStorm = !weather.manualStorm;
        document.getElementById('toggle-storm').classList.toggle('active', weather.manualStorm);

        if (!weather.manualStorm) {
            weather.stormPhase = 'clearing';
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    TERRAIN
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function generateTerrain() {
        terrain = [];
        for (let y = 0; y < terrainSize; y++) {
            terrain[y] = [];
            for (let x = 0; x < terrainSize; x++) {
                terrain[y][x] = { type: TERRAIN.UNKNOWN, explored: false };
            }
        }

        for (let i = 0; i < 12; i++) {
            const cx = Math.floor(seededRandom() * terrainSize);
            const cy = Math.floor(seededRandom() * terrainSize);
            const r = 1 + Math.floor(seededRandom() * 2);
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    if (dx*dx + dy*dy <= r*r) {
                        const tx = safeMod(cx + dx, terrainSize);
                        const ty = safeMod(cy + dy, terrainSize);
                        terrain[ty][tx].type = TERRAIN.OBSTACLE;
                    }
                }
            }
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    FAULTS & PULSES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function injectFault(droneId = null) {
        const candidates = drones.filter(d => !d.isFaulty);
        if (candidates.length === 0) return;

        const target = droneId !== null
            ? drones.find(d => d.id === droneId)
            : candidates[Math.floor(seededRandom() * candidates.length)];

        if (!target || target.isFaulty) return;

        // Bracts have fault resistance
        const zooidBehavior = applyZooidBehavior(target);
        if (seededRandom() < zooidBehavior.faultResist) {
            log(`üõ°Ô∏è Bract ${target.id} resisted fault!`, 'zooid');
            return;
        }

        target.isFaulty = true;
        target.beta = 0;
        target.faultCycle = cycle;

        faults.push({ droneId: target.id, cycle });
        if (faults.length > MAX_FAULTS) faults.shift();
        sessionStats.totalFaults++;

        // Trigger red wave from nearby drones
        if (features.skin) {
            drones.filter(d => !d.isFaulty && target.signalStrengths && target.signalStrengths[d.id] > 0.3)
                  .forEach(d => propagateSkinWave(d, '#ef4444'));
        }

        log(`üí• FAULT: Drone ${target.id} (${target.zooidType})`, 'fault');
    }

    function checkRandomFaults() {
        const baseFaultRate = parseInt(document.getElementById('fault-rate').value) / 100;
        // Apply stress multiplier if stress test is active
        const stressMult = (typeof getStressMultipliers === 'function') ? getStressMultipliers().fault : 1;
        const faultRate = baseFaultRate * stressMult;
        if (seededRandom() < faultRate / 100) {
            injectFault();
        }
    }

    function sendRecalibrationPulse() {
        const strength = 0.3;
        const prePsi = computeOrderParameter().coherence;

        drones.forEach(d => {
            if (d.isFaulty) return;

            const nudge = (PULSE_ATTRACTOR - Math.abs(d.s)) * strength * 0.5;
            d.s += nudge;
            d.pulseBoost = strength * 0.1;

            // Blue ring flash
            if (features.skin) {
                d.skinState = 'blue_ring';
                d.skinIntensity = 1;
            }
        });

        showPulseRing();
        showPulseIndicator();

        const postPsi = computeOrderParameter().coherence;
        const gain = postPsi - prePsi;
        pulseStats.psiGains.push(gain);
        if (pulseStats.psiGains.length > MAX_PSI_GAINS) pulseStats.psiGains.shift();
        pulseStats.count++;
        pulseStats.lastCycle = cycle;
        pulseStats.nextCycle = cycle + parseInt(document.getElementById('pulse-interval').value);

        // Trigger metachronal wave from base
        if (features.wave && seededRandom() < 0.3) {
            const angle = seededRandom() * Math.PI * 2;
            initiateMetachronalWave(base, { x: Math.cos(angle), y: Math.sin(angle) });
        }

        log(`üì° Global pulse: Œ® ${prePsi.toFixed(3)} ‚Üí ${postPsi.toFixed(3)}`, 'pulse');
    }

    function showPulseRing() {
        const container = document.getElementById('map-container');
        const canvas = document.getElementById('map-canvas');
        const size = parseInt(document.getElementById('swarm-size').value);
        const sqrtSize = Math.sqrt(size);
        const scaleX = canvas.width / sqrtSize;
        const scaleY = canvas.height / sqrtSize;

        const ring = document.createElement('div');
        ring.className = 'pulse-ring';
        ring.style.left = (base.x * scaleX - 20) + 'px';
        ring.style.top = (base.y * scaleY - 20) + 'px';
        ring.style.width = '40px';
        ring.style.height = '40px';
        container.appendChild(ring);

        setTimeout(() => ring.remove(), 1000);
    }

    function showPulseIndicator() {
        const indicator = document.getElementById('pulse-indicator');
        indicator.classList.remove('local');
        indicator.textContent = 'üì° RECALIBRATION PULSE';
        indicator.classList.add('active');
        setTimeout(() => indicator.classList.remove('active'), 1500);
    }

    function manualPulse() {
        sendRecalibrationPulse();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    DATA COLLECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function collectDataPoint() {
        const order = computeOrderParameter();
        const components = computeConnectedComponents();
        const cascading = drones.filter(d => d.isCascading).length;
        const betas = drones.map(d => d.beta);
        const vectorCoherence = computeVectorCoherence();

        // Arm coherences
        const armCoherences = arms.map(a => a.coherence || 0);
        const avgArmCoherence = armCoherences.length > 0
            ? armCoherences.reduce((a, b) => a + b, 0) / armCoherences.length
            : 0;

        const dataPoint = {
            cycle,
            coherence: order.coherence,
            meanField: order.mean,
            variance: order.variance,
            giantSize: components.giantSize,
            giantPct: components.giantSize / drones.length,
            numComponents: components.numComponents,
            isolated: components.isolated,
            faultCount: faults.length,
            cascadingCount: cascading,
            avgBeta: betas.reduce((a, b) => a + b, 0) / betas.length,
            stormIntensity: weather.stormIntensity,
            avgArmCoherence,
            vectorCovariance: vectorCoherence.covariance,
            healCount,
            zooidDistribution: {
                nectophore: drones.filter(d => d.zooidType === 'nectophore').length,
                gastrozooid: drones.filter(d => d.zooidType === 'gastrozooid').length,
                bract: drones.filter(d => d.zooidType === 'bract').length
            }
        };

        experimentData.push(dataPoint);
        if (experimentData.length > MAX_EXPERIMENT_DATA) experimentData.shift();

        coherenceHistory.push(order.coherence);
        giantHistory.push(components.giantSize / drones.length);
        armCoherenceHistory.push(avgArmCoherence);

        if (coherenceHistory.length > MAX_HISTORY) {
            coherenceHistory.shift();
            giantHistory.shift();
            armCoherenceHistory.shift();
        }

        return { order, components, cascading, vectorCoherence };
    }

    function exportCSV() {
        if (experimentData.length === 0) return alert('No data');
        const headers = ['cycle', 'coherence', 'meanField', 'variance', 'giantSize', 'giantPct',
                        'numComponents', 'isolated', 'faultCount', 'cascadingCount', 'avgBeta',
                        'stormIntensity', 'avgArmCoherence', 'vectorCovariance', 'healCount'];
        const csv = [headers.join(','), ...experimentData.map(r =>
            headers.map(h => typeof r[h] === 'number' ? r[h].toFixed(6) : r[h]).join(',')
        )].join('\n');
        downloadFile(csv, 'aion_octopus_' + Date.now() + '.csv', 'text/csv');
    }

    function exportJSON() {
        if (experimentData.length === 0) return alert('No data');
        const obj = {
            metadata: {
                swarmSize: parseInt(document.getElementById('swarm-size').value),
                armCount: parseInt(document.getElementById('arm-count').value),
                betaMode: document.getElementById('beta-mode').value,
                features: { ...features },
                totalCycles: cycle,
                totalFaults: faults.length,
                totalHeals: healCount,
                totalPulses: pulseStats.count,
                totalLocalPulses: pulseStats.localPulses
            },
            faults,
            data: experimentData
        };
        downloadFile(JSON.stringify(obj, null, 2), 'aion_octopus_' + Date.now() + '.json', 'application/json');
    }

    function downloadFile(content, filename, type) {
        const blob = new Blob([content], { type });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function initExperiment() {
        const size = parseInt(document.getElementById('swarm-size').value);
        const sqrtSize = Math.sqrt(size);

        rngSeed = 42 + Date.now() % 1000;

        drones = [];
        faults = [];
        experimentData = [];
        coherenceHistory = [];
        giantHistory = [];
        armCoherenceHistory = [];
        cycle = 0;
        healCount = 0;
        bloomActive = false;
        activeWave = null;
        weather = { stormIntensity: 0, stormPhase: 'clear', stormDuration: 0, nextStormCycle: 150, manualStorm: false };
        pulseStats = { count: 0, lastCycle: null, nextCycle: parseInt(document.getElementById('pulse-interval').value), psiGains: [], localPulses: 0 };

        // Reset new cephalopod features
        autotomyEvents = [];
        regenQueue = [];
        totalAutotomies = 0;
        totalRegens = 0;
        lastPanicCycle = -100;
        panicCount = 0;
        myogenicWaves = [];
        eudoxids = [];
        eudoxidIdCounter = 0;

        // Reset trit system
        tritWaveActive = false;
        tritWaveOrigin = null;
        tritWaveRadius = 0;
        tritWaveValue = TRIT.ZERO;
        tritTransitions = { posToZero: 0, zeroToNeg: 0, negToPos: 0, total: 0 };
        voteHistory = [];
        consensusHistory = [];

        // Reset liminal mode
        liminalMode = false;
        liminalCycles = 0;
        totalLiminalEvents = 0;

        // Reset CEG state
        cegMode = CEG_MODE.DEM;
        cegCyclesInMode = 0;
        cegPendingMode = null;
        cegPendingCycles = 0;
        cegModeHistory = [];
        cegEffectiveBeta = 0;
        cegEffectiveCoupling = 1.0;
        cegEffectiveConsensus = 0.66;
        totalModeTransitions = 0;
        applyGovernanceMode();

        // Reset predictive mode selection
        metricHistory = { entropy: [], flipRate: [], coherence: [], faults: [] };
        predictedMode = null;
        predictionConfidence = 0;
        preemptiveTransitions = 0;

        // Reset epistemic memory
        epistemicMemory = [];
        currentEpisode = null;
        memoryHits = 0;
        memorySuccessRate = 0.5;

        // Reset oracle system
        oracleCalibrations = 0;
        oracleAccuracy = 0.5;

        // Reset multi-oracle consensus
        oracleConsensusValue = 0;
        oracleDisagreement = 0;
        oracleConflictEvents = 0;

        // Reset temporal oracle drift
        totalOracleDrift = 0;
        driftReversals = 0;

        // Reset cross-swarm memory sharing
        sharedMemoryPool = [];
        lastMemoryShare = 0;
        memoryInheritanceCount = 0;
        memoryGenerations = 0;

        generateTerrain();

        // Initialize oracles after terrain
        initOracles();

        base = new MobileBase(sqrtSize / 2, sqrtSize / 2);

        for (let i = 0; i < size; i++) {
            const angle = (i / size) * Math.PI * 2;
            const radius = 0.5 + seededRandom() * 1.5;
            drones.push(new Drone(i, base.x + Math.cos(angle) * radius, base.y + Math.sin(angle) * radius));
        }

        initializeArms();

        log('üêô Experiment initialized: ' + size + ' drones, ' + arms.length + ' arms', 'component');
        updateDisplay();
        render();
    }

    function runCycle() {
        cycle++;

        updateWeather();
        checkRandomFaults();
        checkSelfHealing();

        // Bloom countdown
        if (bloomActive) {
            bloomCycles--;
            if (bloomCycles <= 0) {
                endBloom();
            }
        }

        // Automatic global pulse
        if (cycle >= pulseStats.nextCycle) {
            sendRecalibrationPulse();
        }

        // Update features
        updateArmDynamics();
        updateSkinStates();
        updateZooidSpecialization();
        updateMetachronalWave();

        // New cephalopod features
        updatePolarizationChannel();
        checkAutotomy();
        processRegeneration();
        checkPanicConditions();
        updateMyogenicWaves();
        updateVectorSkinCoupling();

        // Trit system
        updateTritWave();
        checkEudoxidRelease();
        updateEudoxids();

        // Liminal / Compression mode
        checkLiminalTrigger();
        processLiminalMode();

        // Contextual Epistemic Governance
        updateCEG();
        updateAdvancedCEG();  // Predictive + Memory + Oracle

        // Update drones
        drones.forEach(d => d.update());

        // Update base
        const activeDrones = drones.filter(d => d.inGiantComponent);
        if (activeDrones.length > 0) {
            const centroid = {
                x: activeDrones.reduce((s, d) => s + d.x, 0) / activeDrones.length,
                y: activeDrones.reduce((s, d) => s + d.y, 0) / activeDrones.length
            };
            base.update(centroid);
        }

        collectDataPoint();
        updateDisplay();
        render();
        renderChart();

        // Live analysis dashboard
        updateDashboard();
    }

    function toggleFeature(name) {
        features[name] = !features[name];
        document.getElementById('toggle-' + name).classList.toggle('active', features[name]);

        if (name === 'arms') {
            if (features.arms) initializeArms();
            else drones.forEach(d => { d.isGanglion = false; d.armId = 0; });
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    RENDERING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function render() {
        const canvas = document.getElementById('map-canvas');
        const ctx = canvas.getContext('2d');
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;

        const size = parseInt(document.getElementById('swarm-size').value);
        const sqrtSize = Math.sqrt(size);
        const scaleX = canvas.width / sqrtSize;
        const scaleY = canvas.height / sqrtSize;
        const cellW = canvas.width / terrainSize;
        const cellH = canvas.height / terrainSize;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Terrain
        for (let y = 0; y < terrainSize; y++) {
            for (let x = 0; x < terrainSize; x++) {
                const cell = terrain[y][x];
                let color = '#050508';
                if (cell.explored) {
                    color = cell.type === TERRAIN.OBSTACLE ? '#78350f' : '#0a0a10';
                }
                ctx.fillStyle = color;
                ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
            }
        }

        // Arm regions (subtle background)
        if (features.arms) {
            arms.forEach((arm, i) => {
                if (arm.drones.length === 0) return;

                ctx.fillStyle = ARM_COLORS[i] + '08';
                ctx.beginPath();

                const armDrones = arm.drones.map(di => drones[di]);
                if (armDrones.length >= 3) {
                    // Convex hull approximation - just draw circles around drones
                    armDrones.forEach(d => {
                        ctx.moveTo(d.x * scaleX + 15, d.y * scaleY);
                        ctx.arc(d.x * scaleX, d.y * scaleY, 15, 0, Math.PI * 2);
                    });
                }
                ctx.fill();
            });
        }

        // Signal links
        drones.forEach(d => {
            Object.entries(d.signalStrengths).forEach(([id, strength]) => {
                if (parseInt(id) < d.id || strength < SIGNAL_LOST_THRESHOLD) return;
                const other = drones.find(dr => dr.id === parseInt(id));
                if (!other) return;

                const sameArm = features.arms && d.armId === other.armId;
                const inGiant = d.inGiantComponent && other.inGiantComponent;

                if (sameArm) {
                    ctx.strokeStyle = ARM_COLORS[d.armId] + '40';
                } else if (inGiant) {
                    ctx.strokeStyle = 'rgba(34, 211, 238, 0.2)';
                } else {
                    ctx.strokeStyle = 'rgba(100, 100, 100, 0.1)';
                }

                ctx.lineWidth = strength * 1.5;
                ctx.beginPath();
                ctx.moveTo(d.x * scaleX, d.y * scaleY);
                ctx.lineTo(other.x * scaleX, other.y * scaleY);
                ctx.stroke();
            });
        });

        // Base (pneumatophore)
        ctx.fillStyle = '#8b5cf6';
        ctx.beginPath();
        ctx.arc(base.x * scaleX, base.y * scaleY, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#a78bfa';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Drones
        drones.forEach(d => {
            const x = d.x * scaleX;
            const y = d.y * scaleY;

            let color, radius = 3;

            if (d.isDetached) {
                // Detached/autotomized drones - faded and drifting
                color = 'rgba(100, 100, 100, 0.4)';
                radius = 2;
            } else if (d.isFaulty) {
                color = '#ef4444';
                radius = 4;
            } else if (d.inEudoxid) {
                // Eudoxid drones - bright cyan with ring
                color = '#22d3ee';
                radius = 3.5;
            } else if (d.isGanglion && features.arms) {
                color = '#f97316';
                radius = 5;
            } else if (d.isRegenerated) {
                // Recently regenerated - pulsing green
                color = '#86efac';
                radius = 3;
            } else if (features.zooid) {
                switch (d.zooidType) {
                    case 'nectophore': color = '#06b6d4'; break;
                    case 'gastrozooid': color = '#eab308'; break;
                    case 'bract': color = '#ec4899'; break;
                    default: color = d.inGiantComponent ? '#4ade80' : '#666';
                }
            } else {
                color = d.inGiantComponent ? '#4ade80' : '#666';
            }

            // Skin state visualization
            if (features.skin && !d.isFaulty) {
                let skinColor = null;
                if (d.skinState === 'red_wave') {
                    skinColor = `rgba(239, 68, 68, ${d.skinIntensity * 0.5})`;
                } else if (d.skinState === 'blue_ring') {
                    skinColor = `rgba(34, 211, 238, ${d.skinIntensity * 0.5})`;
                }

                if (skinColor) {
                    ctx.fillStyle = skinColor;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Axon flash
            if (d.axonFlash) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(x, y, radius + 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // Glow
            const glow = ctx.createRadialGradient(x, y, 0, x, y, radius + 3);
            glow.addColorStop(0, color + '80');
            glow.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(x, y, radius + 3, 0, Math.PI * 2);
            ctx.fill();

            // Core
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();

            // Vector arrow (smaller, less cluttery)
            if (features.vector && !d.isFaulty) {
                const arrowLen = 4;  // Reduced from 8
                const angle = Math.atan2(d.phi, d.theta);
                const mag = Math.min(1.5, Math.sqrt(d.theta * d.theta + d.phi * d.phi));

                ctx.strokeStyle = 'rgba(168, 85, 247, 0.4)';
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(x, y);
                const endX = x + Math.cos(angle) * arrowLen * (0.5 + mag);
                const endY = y + Math.sin(angle) * arrowLen * (0.5 + mag);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                // Tiny arrowhead
                ctx.fillStyle = 'rgba(168, 85, 247, 0.5)';
                ctx.beginPath();
                ctx.arc(endX, endY, 1, 0, Math.PI * 2);
                ctx.fill();
            }

            // Ganglion marker
            if (d.isGanglion && features.arms) {
                ctx.strokeStyle = '#f97316';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, radius + 3, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Fault marker
            if (d.isFaulty) {
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(x - 5, y - 5);
                ctx.lineTo(x + 5, y + 5);
                ctx.moveTo(x + 5, y - 5);
                ctx.lineTo(x - 5, y + 5);
                ctx.stroke();
            }

            // Eudoxid marker (exploration ring)
            if (d.inEudoxid) {
                ctx.strokeStyle = '#22d3ee';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.arc(x, y, radius + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Detached marker (fading X)
            if (d.isDetached) {
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x - 3, y - 3);
                ctx.lineTo(x + 3, y + 3);
                ctx.moveTo(x + 3, y - 3);
                ctx.lineTo(x - 3, y + 3);
                ctx.stroke();
            }
        });

        // Draw eudoxid exploration lines
        eudoxids.forEach(eudoxid => {
            if (eudoxid.dead || eudoxid.reintegrated) return;

            const eudoxidDrones = eudoxid.drones.map(id => drones[id]).filter(d => d);
            if (eudoxidDrones.length === 0) return;

            const centroid = {
                x: eudoxidDrones.reduce((s, d) => s + d.x, 0) / eudoxidDrones.length * scaleX,
                y: eudoxidDrones.reduce((s, d) => s + d.y, 0) / eudoxidDrones.length * scaleY
            };

            // Line to target
            const targetX = (eudoxid.returning ? base.x : eudoxid.target.x) * scaleX;
            const targetY = (eudoxid.returning ? base.y : eudoxid.target.y) * scaleY;

            ctx.strokeStyle = eudoxid.returning ? 'rgba(74, 222, 128, 0.4)' : 'rgba(34, 211, 238, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(centroid.x, centroid.y);
            ctx.lineTo(targetX, targetY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Target marker
            ctx.fillStyle = eudoxid.returning ? '#4ade80' : '#22d3ee';
            ctx.beginPath();
            ctx.arc(targetX, targetY, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        // Draw trit wave ring
        if (tritWaveActive && features.trit && tritWaveOrigin) {
            const waveX = tritWaveOrigin.x * scaleX;
            const waveY = tritWaveOrigin.y * scaleY;
            const waveRadius = tritWaveRadius * scaleX;

            // Wave color based on value
            let waveColor;
            if (tritWaveValue > 0) waveColor = 'rgba(74, 222, 128, 0.6)';
            else if (tritWaveValue < 0) waveColor = 'rgba(239, 68, 68, 0.6)';
            else waveColor = 'rgba(156, 163, 175, 0.6)';

            ctx.strokeStyle = waveColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(waveX, waveY, waveRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner ring (fading)
            const innerRadius = Math.max(0, waveRadius - TRIT_WAVE_WIDTH * scaleX);
            ctx.strokeStyle = waveColor.replace('0.6', '0.3');
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(waveX, waveY, innerRadius, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Highlight drones with trit votes (subtle color tint)
        if (features.trit) {
            drones.forEach(d => {
                if (d.isFaulty || d.isDetached) return;
                const x = d.x * scaleX;
                const y = d.y * scaleY;

                // Trit vote ring
                let tritColor = null;
                if (d.vote === 1) tritColor = 'rgba(74, 222, 128, 0.25)';
                else if (d.vote === -1) tritColor = 'rgba(239, 68, 68, 0.25)';

                if (tritColor) {
                    ctx.fillStyle = tritColor;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Trit wave front highlight
                if (d.inTritWaveFront) {
                    ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
        }

        // Noise visualization - show noise intensity as subtle halo
        if (features.noise) {
            drones.forEach(d => {
                if (d.isFaulty || d.isDetached) return;
                const x = d.x * scaleX;
                const y = d.y * scaleY;

                // Noise level visualization (0.008 base, up to ~0.05 max)
                const noiseLevel = d.adaptiveNoise || SIGMA_BASE;
                const normalizedNoise = Math.min(1, (noiseLevel - SIGMA_BASE) / (SIGMA_BASE * 5));

                if (normalizedNoise > 0.1) {
                    // Color gradient: green (low) -> yellow (medium) -> red (high)
                    const r = Math.floor(255 * Math.min(1, normalizedNoise * 2));
                    const g = Math.floor(255 * Math.min(1, 2 - normalizedNoise * 2));
                    const alpha = 0.15 + normalizedNoise * 0.25;

                    ctx.fillStyle = `rgba(${r}, ${g}, 50, ${alpha})`;
                    ctx.beginPath();
                    const radius = 4 + normalizedNoise * 8;
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // Draw oracle beacons
        if (oracles && oracles.length > 0) {
            const size = Math.sqrt(parseInt(document.getElementById('swarm-size').value));
            oracles.forEach(oracle => {
                const x = oracle.x * scaleX;
                const y = oracle.y * scaleY;
                const radius = ORACLE_RANGE * scaleX;

                // Oracle range circle
                ctx.strokeStyle = 'rgba(251, 191, 36, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Oracle beacon center
                const pulsePhase = (cycle % 25) / 25;
                const pulseScale = 1 + Math.sin(pulsePhase * Math.PI * 2) * 0.3;

                ctx.fillStyle = `rgba(251, 191, 36, ${0.4 + pulseScale * 0.3})`;
                ctx.beginPath();
                ctx.arc(x, y, 4 * pulseScale, 0, Math.PI * 2);
                ctx.fill();

                // Oracle truth indicator (small line showing direction)
                const truthAngle = oracle.truthValue * Math.PI / 2;
                ctx.strokeStyle = oracle.truthValue > 0 ? '#4ade80' : '#ef4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(truthAngle) * 8, y + Math.sin(truthAngle) * 8);
                ctx.stroke();
            });
        }

        document.getElementById('map-overlay').textContent =
            `CYCLE ${cycle} | ${document.getElementById('beta-mode').value.toUpperCase()}` +
            (bloomActive ? ' | BLOOM' : '') +
            (weather.stormIntensity > 0.3 ? ' | STORM' : '') +
            (liminalMode ? ' | üåÄ LIMINAL' : (features.trit ? ' | TRIT' : ''));
    }

    function renderChart() {
        const canvas = document.getElementById('chart-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (coherenceHistory.length < 2) return;

        const w = canvas.width, h = canvas.height, p = 2;

        // Coherence line (pink)
        ctx.strokeStyle = '#ec4899';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        coherenceHistory.forEach((val, i) => {
            const x = p + (i / (MAX_HISTORY - 1)) * (w - 2 * p);
            const y = h - p - val * (h - 2 * p);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.stroke();

        // Giant component line (cyan)
        ctx.strokeStyle = '#22d3ee';
        ctx.lineWidth = 1;
        ctx.beginPath();
        giantHistory.forEach((val, i) => {
            const x = p + (i / (MAX_HISTORY - 1)) * (w - 2 * p);
            const y = h - p - val * (h - 2 * p);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.stroke();

        // Arm coherence (orange)
        if (features.arms && armCoherenceHistory.length > 1) {
            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            armCoherenceHistory.forEach((val, i) => {
                const x = p + (i / (MAX_HISTORY - 1)) * (w - 2 * p);
                const y = h - p - val * (h - 2 * p);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    DISPLAY
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function updateDisplay() {
        const order = computeOrderParameter();
        const components = computeConnectedComponents();
        const cascading = drones.filter(d => d.isCascading).length;
        const vectorCoherence = computeVectorCoherence();

        // Header
        document.getElementById('cycle-val').textContent = cycle.toString().padStart(4, '0');

        const psiVal = document.getElementById('psi-val');
        psiVal.textContent = order.coherence.toFixed(2);
        psiVal.className = 'val ' + (order.coherence > 0.8 ? 'high' : order.coherence > 0.5 ? 'mid' : 'low');

        const giantPct = components.giantSize / drones.length * 100;
        document.getElementById('giant-val').textContent = giantPct.toFixed(0) + '%';
        document.getElementById('arms-val').textContent = arms.filter(a => a.drones.length > 0).length;
        document.getElementById('fault-val').textContent = faults.length;

        const cascadePressure = cascading / drones.length;
        document.getElementById('cascade-val').textContent = cascadePressure.toFixed(2);

        // Giant component
        document.getElementById('giant-display').textContent = `${components.giantSize} / ${drones.length}`;
        document.getElementById('giant-big').textContent = components.giantSize;
        document.getElementById('num-components').textContent = components.numComponents;
        document.getElementById('giant-pct').textContent = giantPct.toFixed(0) + '%';
        document.getElementById('isolated-count').textContent = components.isolated;

        // Component bar
        updateComponentBar(components);

        // Arm stats
        updateArmBar();
        document.getElementById('ganglia-count').textContent = arms.filter(a => a.ganglionId !== null && !drones[a.ganglionId]?.isFaulty).length;
        const avgArmPsi = arms.filter(a => a.coherence !== undefined).reduce((s, a) => s + a.coherence, 0) / Math.max(1, arms.length);
        document.getElementById('intra-arm-psi').textContent = avgArmPsi.toFixed(2);
        document.getElementById('exploring-arms').textContent = arms.filter(a => a.exploring).length;

        // Skin stats
        const opticalStrength = Math.max(0, (1 - weather.stormIntensity * 0.7) * 100);
        document.getElementById('optical-strength').textContent = opticalStrength.toFixed(0) + '%';
        document.getElementById('red-waves').textContent = drones.filter(d => d.skinState === 'red_wave').length;
        document.getElementById('blue-rings').textContent = drones.filter(d => d.skinState === 'blue_ring').length;

        // Zooid counts
        document.getElementById('nectophore-count').textContent = drones.filter(d => d.zooidType === 'nectophore').length;
        document.getElementById('gastrozooid-count').textContent = drones.filter(d => d.zooidType === 'gastrozooid').length;
        document.getElementById('bract-count').textContent = drones.filter(d => d.zooidType === 'bract').length;
        document.getElementById('unspec-count').textContent = drones.filter(d => d.zooidType === 'normal').length;

        // Vector state
        document.getElementById('mean-theta').textContent = vectorCoherence.meanTheta.toFixed(3);
        document.getElementById('mean-phi').textContent = vectorCoherence.meanPhi.toFixed(3);
        document.getElementById('covariance').textContent = vectorCoherence.covariance.toFixed(4);

        // Resilience
        const faultTolerance = (drones.length - faults.length) / drones.length * 100;
        document.getElementById('fault-tolerance').textContent = faultTolerance.toFixed(0) + '%';
        document.getElementById('cascade-resistance').textContent = ((1 - cascadePressure) * 100).toFixed(0) + '%';
        document.getElementById('heal-count').textContent = healCount;

        // Autotomy & Regen
        document.getElementById('autotomy-count').textContent = totalAutotomies;
        document.getElementById('regen-count').textContent = totalRegens;
        document.getElementById('regen-queue').textContent = regenQueue.reduce((s, r) => s + r.count, 0);
        document.getElementById('detached-count').textContent = drones.filter(d => d.isDetached).length;

        // Eudoxids & Panic
        document.getElementById('eudoxid-count').textContent = eudoxids.length;
        const totalTilesRevealed = eudoxids.reduce((s, e) => s + e.terrainRevealed, 0);
        document.getElementById('eudoxid-tiles').textContent = totalTilesRevealed;
        document.getElementById('panic-count').textContent = panicCount;
        document.getElementById('myogenic-count').textContent = myogenicWaves.length;

        // Trit System
        if (features.trit) {
            const consensus = computeTritConsensus();

            // Distribution counts
            document.getElementById('trit-pos-count').textContent = consensus.pos;
            document.getElementById('trit-zero-count').textContent = consensus.zero;
            document.getElementById('trit-neg-count').textContent = consensus.neg;

            // Consensus result
            const consensusEl = document.getElementById('trit-consensus');
            if (consensus.result === 'consensus') {
                consensusEl.textContent = consensus.winner > 0 ? '+1' : consensus.winner < 0 ? '-1' : '0';
                consensusEl.className = 'val ' + (consensus.winner > 0 ? 'good' : consensus.winner < 0 ? 'bad' : '');
            } else if (consensus.result === 'deadlock') {
                consensusEl.textContent = 'DEADLOCK';
                consensusEl.className = 'val warn';
            } else {
                consensusEl.textContent = 'pending';
                consensusEl.className = 'val';
            }

            // Entropy and margin
            document.getElementById('trit-entropy').textContent = consensus.entropy.toFixed(2);
            document.getElementById('trit-margin').textContent = (consensus.margin * 100).toFixed(0) + '%';

            // Bandwidth compression
            const activeDrones = drones.filter(d => !d.isFaulty && !d.isDetached).length;
            const bitsBefore = activeDrones * 64;
            const bitsAfter = activeDrones * 5;
            document.getElementById('trit-bits-before').textContent = bitsBefore + ' b';
            document.getElementById('trit-bits-after').textContent = bitsAfter + ' b';
            document.getElementById('trit-compression').textContent = Math.round((1 - bitsAfter / bitsBefore) * 100) + '%';
            document.getElementById('trit-transitions').textContent = tritTransitions.total;

            // Consensus indicator on map
            const consensusIndicator = document.getElementById('consensus-indicator');
            const consensusBig = document.getElementById('consensus-big');
            if (consensus.result === 'consensus') {
                consensusIndicator.classList.add('active');
                consensusBig.textContent = consensus.winner > 0 ? '+1' : consensus.winner < 0 ? '-1' : '0';
                consensusBig.className = 'val ' + (consensus.winner > 0 ? 'pos' : consensus.winner < 0 ? 'neg' : 'zero');
            } else {
                consensusIndicator.classList.remove('active');
            }

            // Trit wave indicator
            const tritWaveIndicator = document.getElementById('trit-wave-indicator');
            if (tritWaveActive) {
                tritWaveIndicator.classList.add('active');
            } else {
                tritWaveIndicator.classList.remove('active');
            }
        }

        // Adaptive Noise
        if (features.noise) {
            const noiseStats = getNoiseStats();

            // Update noise metrics
            document.getElementById('noise-min').textContent = noiseStats.min.toFixed(4);
            document.getElementById('noise-avg-val').textContent = noiseStats.avg.toFixed(4);
            document.getElementById('noise-max').textContent = noiseStats.max.toFixed(4);
            document.getElementById('noise-variance').textContent = noiseStats.variance.toFixed(6);

            // Update noise bar (0 to 0.05 range)
            const maxNoise = SIGMA_BASE * 6;  // Max expected noise
            const fillPct = Math.min(100, (noiseStats.avg / maxNoise) * 100);
            const markerPct = Math.min(100, (noiseStats.max / maxNoise) * 100);

            document.getElementById('noise-fill').style.width = fillPct + '%';
            document.getElementById('noise-marker').style.left = markerPct + '%';

            // Noise indicator on map
            const noiseIndicator = document.getElementById('noise-indicator');
            noiseIndicator.classList.add('active');
            document.getElementById('noise-avg').textContent = noiseStats.avg.toFixed(4);

            // Color the indicator based on noise level
            const avgEl = document.getElementById('noise-avg');
            if (noiseStats.avg > SIGMA_BASE * 3) {
                avgEl.style.color = '#ef4444';  // Red - high noise
            } else if (noiseStats.avg > SIGMA_BASE * 1.5) {
                avgEl.style.color = '#fbbf24';  // Yellow - medium noise
            } else {
                avgEl.style.color = '#4ade80';  // Green - low noise
            }
        }

        // Liminal Mode Indicator
        const liminalOverlay = document.getElementById('liminal-overlay');
        const liminalIndicator = document.getElementById('liminal-indicator');
        if (liminalMode) {
            liminalOverlay.classList.add('active');
            liminalIndicator.classList.add('active');
            liminalIndicator.textContent = `üåÄ LIMINAL [${liminalCycles}/${LIMINAL_MAX_CYCLES}]`;
        } else {
            liminalOverlay.classList.remove('active');
            liminalIndicator.classList.remove('active');
        }

        // CEG Governance Mode Indicator
        const cegIndicator = document.getElementById('ceg-indicator');
        const cegPending = document.getElementById('ceg-pending');
        const modeEmojis = { DEM: 'üó≥Ô∏è', EPI: 'üéì', SEN: 'üõ°Ô∏è', EMG: 'üö®' };

        // Update indicator class and content
        cegIndicator.className = 'ceg-indicator ' + cegMode;
        cegIndicator.innerHTML = `
            <span class="ceg-emoji">${modeEmojis[cegMode]}</span>
            <span class="ceg-label">${CEG_LABELS[cegMode]}</span>
            <span class="ceg-cycles">[${cegCyclesInMode}]</span>
        `;

        // Show pending transition if any
        if (cegPendingMode && cegPendingCycles > 0) {
            cegPending.classList.add('active');
            cegPending.textContent = `‚Üí ${CEG_LABELS[cegPendingMode]} (${cegPendingCycles}/${CEG_STABILITY_WINDOW})`;
        } else {
            cegPending.classList.remove('active');
        }

        // Advanced CEG Panel
        document.getElementById('preemptive-count').textContent = preemptiveTransitions;
        document.getElementById('memory-hits').textContent = memoryHits;

        const memSuccessEl = document.getElementById('memory-success');
        memSuccessEl.textContent = (memorySuccessRate * 100).toFixed(0) + '%';
        memSuccessEl.className = 'metric-val ' + (memorySuccessRate > 0.7 ? 'good' : memorySuccessRate > 0.4 ? '' : 'bad');

        const oracleAccEl = document.getElementById('oracle-accuracy');
        oracleAccEl.textContent = (oracleAccuracy * 100).toFixed(0) + '%';
        oracleAccEl.className = 'metric-val ' + (oracleAccuracy > 0.7 ? 'good' : oracleAccuracy > 0.4 ? 'warn' : 'bad');

        document.getElementById('oracle-calibrations').textContent = oracleCalibrations;
        document.getElementById('oracle-conflicts').textContent = oracleConflictEvents;
        document.getElementById('memory-inherited').textContent = memoryInheritanceCount;

        // Prediction indicator
        const predIndicator = document.getElementById('prediction-indicator');
        if (predictedMode && predictionConfidence > 0.3) {
            predIndicator.classList.add('active');
            document.getElementById('pred-mode').textContent = CEG_LABELS[predictedMode];
            document.getElementById('pred-conf').textContent = `(${(predictionConfidence * 100).toFixed(0)}%)`;
        } else {
            predIndicator.classList.remove('active');
        }

        // Memory indicator
        const memIndicator = document.getElementById('memory-indicator');
        if (epistemicMemory.length > 0) {
            memIndicator.classList.add('active');
            document.getElementById('episode-count').textContent = epistemicMemory.length;
        } else {
            memIndicator.classList.remove('active');
        }

        // Shared memory indicator
        const sharedMemIndicator = document.getElementById('shared-memory-indicator');
        if (sharedMemoryPool.length > 0 || memoryGenerations > 0) {
            sharedMemIndicator.classList.add('active');
            document.getElementById('shared-pool-size').textContent = sharedMemoryPool.length;
            document.getElementById('memory-gen').textContent = memoryGenerations;
        } else {
            sharedMemIndicator.classList.remove('active');
        }

        // Oracle status (disagreement and drift)
        document.getElementById('disagreement-fill').style.width = (oracleDisagreement * 100) + '%';

        const driftStatus = getOracleDriftStatus();
        const driftEl = document.getElementById('drift-indicator');
        driftEl.textContent = `Drift: ${driftStatus.direction} (${driftStatus.reversals} rev)`;
        driftEl.style.color = driftStatus.direction === 'stable' ? '#4ade80' :
                              driftStatus.direction === 'mixed' ? '#fbbf24' : '#ef4444';

        // Flash conflict indicator when conflicts happen
        const conflictFlash = document.getElementById('conflict-flash');
        if (oracleConflictEvents > 0 && cycle % 30 < 2) {
            conflictFlash.classList.add('active');
            setTimeout(() => conflictFlash.classList.remove('active'), 500);
        }

        // Sliders
        document.getElementById('speed-display').textContent = document.getElementById('speed').value + 'ms';
        document.getElementById('fault-rate-display').textContent = document.getElementById('fault-rate').value + '%';
    }

    function updateComponentBar(components) {
        const bar = document.getElementById('component-bar');
        const colors = ['#22d3ee', '#8b5cf6', '#f97316', '#ef4444', '#666'];

        bar.innerHTML = components.components.slice(0, 5).map((comp, i) => {
            const pct = comp.length / drones.length * 100;
            return `<div class="segment" style="width: ${pct}%; background: ${colors[i]};"></div>`;
        }).join('');
    }

    function updateArmBar() {
        const bar = document.getElementById('arm-bar');
        const total = drones.length;

        bar.innerHTML = arms.map((arm, i) => {
            const pct = (arm.drones.length / total) * 100;
            const healthy = arm.drones.filter(di => drones[di] && !drones[di].isFaulty).length;
            const opacity = healthy > 0 ? 1 : 0.4;
            return `<div class="segment" style="width: ${pct}%; background: ${ARM_COLORS[i]}; opacity: ${opacity};">${healthy}</div>`;
        }).join('');
    }

    function log(msg, type = 'info') {
        const logEl = document.getElementById('log');
        const entry = document.createElement('div');
        entry.className = 'log-entry ' + type;
        entry.textContent = `[${cycle}] ${msg}`;
        logEl.prepend(entry);
        while (logEl.children.length > 20) logEl.lastChild.remove();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //                    CONTROLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function toggleSim() {
        isRunning = !isRunning;
        const btn = document.getElementById('start-btn');
        btn.textContent = isRunning ? '‚è∏' : '‚ñ∂';
        btn.classList.toggle('active', isRunning);
        if (isRunning) runLoop();
        else clearTimeout(timer);
    }

    function stepSim() { runCycle(); }

    function runLoop() {
        if (!isRunning) return;
        runCycle();
        timer = setTimeout(runLoop, parseInt(document.getElementById('speed').value));
    }

    window.onload = initExperiment;
    window.onresize = () => { render(); renderChart(); };
</script>

<!-- Command Console -->
<div class="command-console collapsed" id="command-console">
    <div class="console-header" onclick="toggleConsole()">
        <h4>
            <span class="toggle-icon">‚ñ≤</span>
            AION COMMAND CONSOLE
        </h4>
        <div class="console-status">
            <span class="status-item">Cycle: <span id="console-cycle">0</span></span>
            <span class="status-item ceg-mode dem" id="console-ceg-mode">DEM</span>
            <span class="status-item">œà: <span id="console-psi">0.00</span></span>
        </div>
    </div>
    <div class="console-output" id="console-output">
        <div class="console-line system">AION Command Console v1.0 initialized</div>
        <div class="console-line system">Type 'help' for available commands</div>
    </div>
    <div class="console-suggestions" id="console-suggestions"></div>
    <div class="console-input-row">
        <span class="console-prompt">AION></span>
        <input type="text" class="console-input" id="console-input"
               placeholder="Enter command..."
               onkeydown="handleConsoleKeydown(event)"
               oninput="handleConsoleInput(event)"
               autocomplete="off">
    </div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//                    COMMAND CONSOLE SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const COMMAND_HISTORY_MAX = 50;
let commandHistory = [];
let historyIndex = -1;
let consoleExpanded = false;

// Command taxonomy with descriptions
const COMMANDS = {
    // Query commands
    'help': { desc: 'Show available commands', category: 'META' },
    'status': { desc: 'Show current swarm status', category: 'QUERY' },
    'query ceg': { desc: 'Show CEG governance state', category: 'QUERY' },
    'query coherence': { desc: 'Show coherence metrics', category: 'QUERY' },
    'query memory': { desc: 'Show epistemic memory episodes', category: 'QUERY' },
    'query oracle': { desc: 'Show oracle status and drift', category: 'QUERY' },
    'query arms': { desc: 'Show arm status breakdown', category: 'QUERY' },

    // Inject commands
    'inject fault': { desc: 'Inject faults (e.g., inject fault 20%)', category: 'INJECT' },
    'inject storm': { desc: 'Trigger environmental storm', category: 'INJECT' },
    'inject blackout': { desc: 'Simulate communication blackout', category: 'INJECT' },

    // Set commands
    'set waypoint': { desc: 'Set swarm target (e.g., set waypoint 400,300)', category: 'SET' },
    'set mode': { desc: 'Force CEG mode (e.g., set mode epi)', category: 'SET' },
    'set speed': { desc: 'Set simulation speed (e.g., set speed 50)', category: 'SET' },
    'set faultrate': { desc: 'Set fault injection rate', category: 'SET' },

    // Mission commands
    'mission forage': { desc: 'Start resource foraging mission', category: 'MISSION' },
    'mission patrol': { desc: 'Start patrol pattern', category: 'MISSION' },
    'mission converge': { desc: 'Converge swarm to center', category: 'MISSION' },
    'mission disperse': { desc: 'Disperse swarm outward', category: 'MISSION' },

    // Control commands
    'start': { desc: 'Start simulation', category: 'CONTROL' },
    'stop': { desc: 'Stop simulation', category: 'CONTROL' },
    'reset': { desc: 'Reset experiment', category: 'CONTROL' },
    'pulse': { desc: 'Trigger recalibration pulse', category: 'CONTROL' },

    // Meta commands
    'clear': { desc: 'Clear console output', category: 'META' },
    'history': { desc: 'Show command history', category: 'META' },
    'export': { desc: 'Export data (csv or json)', category: 'META' }
};

function toggleConsole() {
    const cmdConsole = document.getElementById('command-console');
    consoleExpanded = !consoleExpanded;
    cmdConsole.classList.toggle('expanded', consoleExpanded);
    cmdConsole.classList.toggle('collapsed', !consoleExpanded);
    if (consoleExpanded) {
        document.getElementById('console-input').focus();
    }
}

function consoleLog(message, type = 'output') {
    const output = document.getElementById('console-output');
    const line = document.createElement('div');
    line.className = `console-line ${type}`;
    line.textContent = message;
    output.appendChild(line);
    output.scrollTop = output.scrollHeight;

    // Limit console lines
    while (output.children.length > 200) {
        output.removeChild(output.firstChild);
    }
}

function handleConsoleKeydown(event) {
    const input = document.getElementById('console-input');
    const suggestions = document.getElementById('console-suggestions');

    if (event.key === 'Enter') {
        const cmd = input.value.trim();
        if (cmd) {
            executeCommand(cmd);
            commandHistory.unshift(cmd);
            if (commandHistory.length > COMMAND_HISTORY_MAX) commandHistory.pop();
            historyIndex = -1;
        }
        input.value = '';
        suggestions.classList.remove('active');
        event.preventDefault();
    } else if (event.key === 'ArrowUp') {
        if (historyIndex < commandHistory.length - 1) {
            historyIndex++;
            input.value = commandHistory[historyIndex];
        }
        event.preventDefault();
    } else if (event.key === 'ArrowDown') {
        if (historyIndex > 0) {
            historyIndex--;
            input.value = commandHistory[historyIndex];
        } else if (historyIndex === 0) {
            historyIndex = -1;
            input.value = '';
        }
        event.preventDefault();
    } else if (event.key === 'Tab') {
        // Autocomplete
        const matches = getCommandMatches(input.value);
        if (matches.length === 1) {
            input.value = matches[0];
        }
        event.preventDefault();
    } else if (event.key === 'Escape') {
        suggestions.classList.remove('active');
        input.blur();
    }
}

function handleConsoleInput(event) {
    const input = event.target.value;
    const suggestions = document.getElementById('console-suggestions');

    if (input.length > 0) {
        const matches = getCommandMatches(input);
        if (matches.length > 0 && matches.length <= 8) {
            suggestions.innerHTML = matches.map(cmd =>
                `<div class="suggestion-item" onclick="selectSuggestion('${cmd}')">
                    <span class="cmd">${cmd}</span>
                    <span class="desc">${COMMANDS[cmd]?.desc || ''}</span>
                </div>`
            ).join('');
            suggestions.classList.add('active');
        } else {
            suggestions.classList.remove('active');
        }
    } else {
        suggestions.classList.remove('active');
    }
}

function selectSuggestion(cmd) {
    document.getElementById('console-input').value = cmd + ' ';
    document.getElementById('console-suggestions').classList.remove('active');
    document.getElementById('console-input').focus();
}

function getCommandMatches(input) {
    const lower = input.toLowerCase();
    return Object.keys(COMMANDS).filter(cmd => cmd.startsWith(lower));
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//                    CEG COMMAND GOVERNANCE GATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Command risk levels
const COMMAND_RISK = {
    'help': 0, 'status': 0, 'query': 0, 'clear': 0, 'history': 0, 'export': 0,
    'start': 1, 'stop': 1, 'pulse': 1,
    'set': 2, 'mission': 2,
    'inject': 3, 'reset': 3
};

// CEG mode permissions (max risk level allowed)
const CEG_PERMISSIONS = {
    'DEM': 3,  // Democratic: all commands allowed
    'EPI': 3,  // Epistemic: all commands, ganglion-weighted
    'SEN': 2,  // Sentinel: blocks high-risk (inject, reset)
    'EMG': 1   // Emergency: only safe commands
};

function validateCommandWithCEG(cmd, args) {
    const mode = typeof cegMode !== 'undefined' ? cegMode : 'DEM';
    const riskLevel = COMMAND_RISK[cmd] || 0;
    const maxAllowed = CEG_PERMISSIONS[mode] || 3;

    // Always allow safe commands
    if (riskLevel === 0) {
        return { allowed: true, mode, riskLevel };
    }

    // Check if command exceeds current mode's permission
    if (riskLevel > maxAllowed) {
        return {
            allowed: false,
            mode,
            riskLevel,
            reason: `Command '${cmd}' blocked by CEG ${mode} mode (risk ${riskLevel} > max ${maxAllowed})`
        };
    }

    // SEN mode: warn but allow medium-risk
    if (mode === 'SEN' && riskLevel === 2) {
        return {
            allowed: true,
            mode,
            riskLevel,
            warning: `CEG SEN mode: Command '${cmd}' allowed with caution`
        };
    }

    // EMG mode: extra warning for any non-safe command
    if (mode === 'EMG' && riskLevel > 0) {
        return {
            allowed: true,
            mode,
            riskLevel,
            warning: `CEG EMG mode: Emergency override active`
        };
    }

    return { allowed: true, mode, riskLevel };
}

function executeCommand(cmdString) {
    consoleLog(cmdString, 'input');

    const parts = cmdString.toLowerCase().trim().split(/\s+/);
    const cmd = parts[0];
    const args = parts.slice(1);

    // CEG Governance Gate
    const validation = validateCommandWithCEG(cmd, args);
    if (!validation.allowed) {
        consoleLog(validation.reason, 'error');
        consoleLog(`Current CEG mode: ${validation.mode} | Use 'set mode dem' to override`, 'warning');
        triggerAlert('CMD_BLOCKED', `Command '${cmd}' blocked by CEG ${validation.mode}`);
        return;
    }
    if (validation.warning) {
        consoleLog(validation.warning, 'warning');
    }

    try {
        switch (cmd) {
            case 'help':
                showHelp(args[0]);
                break;
            case 'status':
                showStatus();
                break;
            case 'query':
                handleQuery(args);
                break;
            case 'inject':
                handleInject(args);
                break;
            case 'set':
                handleSet(args);
                break;
            case 'mission':
                handleMission(args);
                break;
            case 'start':
                startExperiment();
                consoleLog('Simulation started', 'success');
                break;
            case 'stop':
                stopExperiment();
                consoleLog('Simulation stopped', 'success');
                break;
            case 'reset':
                initExperiment();
                consoleLog('Experiment reset', 'success');
                break;
            case 'pulse':
                triggerRecalibrationPulse();
                consoleLog('Recalibration pulse triggered', 'success');
                break;
            case 'clear':
                document.getElementById('console-output').innerHTML = '';
                break;
            case 'history':
                commandHistory.slice(0, 10).forEach((h, i) => consoleLog(`${i + 1}: ${h}`, 'output'));
                break;
            case 'export':
                if (args[0] === 'json') {
                    exportJSON();
                    consoleLog('JSON exported', 'success');
                } else {
                    exportCSV();
                    consoleLog('CSV exported', 'success');
                }
                break;
            case 'alerts':
                handleAlerts(args);
                break;
            case 'telegram':
                handleTelegram(args);
                break;
            default:
                consoleLog(`Unknown command: ${cmd}. Type 'help' for available commands.`, 'error');
        }
    } catch (err) {
        consoleLog(`Error: ${err.message}`, 'error');
    }
}

function showHelp(category) {
    if (category) {
        const cat = category.toUpperCase();
        consoleLog(`Commands in ${cat}:`, 'info');
        Object.entries(COMMANDS)
            .filter(([_, v]) => v.category === cat)
            .forEach(([cmd, v]) => consoleLog(`  ${cmd} - ${v.desc}`, 'output'));
    } else {
        consoleLog('Available command categories:', 'info');
        consoleLog('  QUERY   - status, ceg, coherence, memory, oracle, arms', 'output');
        consoleLog('  INJECT  - fault, storm, blackout', 'output');
        consoleLog('  SET     - waypoint, mode, speed, faultrate', 'output');
        consoleLog('  MISSION - forage, patrol, converge, disperse', 'output');
        consoleLog('  CONTROL - start, stop, reset, pulse', 'output');
        consoleLog('  META    - help, clear, history, export', 'output');
        consoleLog('Type "help <category>" for detailed commands', 'info');
    }
}

function showStatus() {
    const psi = typeof computeOrderParameter === 'function' ? computeOrderParameter().coherence : 0;
    const mode = typeof cegMode !== 'undefined' ? cegMode : 'N/A';
    const faultCount = typeof faults !== 'undefined' ? faults.length : 0;
    const droneCount = typeof drones !== 'undefined' ? drones.length : 0;

    consoleLog(`=== SWARM STATUS @ Cycle ${cycle} ===`, 'info');
    consoleLog(`  Drones: ${droneCount} | Faults: ${faultCount}`, 'output');
    consoleLog(`  Coherence (œà): ${psi.toFixed(3)}`, 'output');
    consoleLog(`  CEG Mode: ${mode} (${typeof cegCyclesInMode !== 'undefined' ? cegCyclesInMode : 0} cycles)`, 'output');
    consoleLog(`  Running: ${isRunning ? 'YES' : 'NO'}`, 'output');
}

function handleQuery(args) {
    const target = args[0];
    switch (target) {
        case 'ceg':
            queryCEG();
            break;
        case 'coherence':
            queryCoherence();
            break;
        case 'memory':
            queryMemory();
            break;
        case 'oracle':
            queryOracle();
            break;
        case 'arms':
            queryArms();
            break;
        default:
            consoleLog('Usage: query <ceg|coherence|memory|oracle|arms>', 'warning');
    }
}

function queryCEG() {
    const mode = typeof cegMode !== 'undefined' ? cegMode : 'N/A';
    const cyclesIn = typeof cegCyclesInMode !== 'undefined' ? cegCyclesInMode : 0;
    const metrics = typeof getCEGMetrics === 'function' ? getCEGMetrics() : {};

    consoleLog(`=== CEG GOVERNANCE STATE ===`, 'info');
    consoleLog(`  Current Mode: ${mode}`, 'output');
    consoleLog(`  Cycles in Mode: ${cyclesIn}`, 'output');
    if (metrics.entropy !== undefined) {
        consoleLog(`  Entropy: ${metrics.entropy.toFixed(3)}`, 'output');
        consoleLog(`  Flip Rate: ${metrics.flipRate.toFixed(3)}`, 'output');
        consoleLog(`  Fault Ratio: ${metrics.faultRatio.toFixed(3)}`, 'output');
        consoleLog(`  Coherence: ${metrics.coherence.toFixed(3)}`, 'output');
    }
    if (typeof predictedMode !== 'undefined' && predictedMode) {
        consoleLog(`  Predicted Next: ${predictedMode} (${(predictionConfidence * 100).toFixed(0)}% conf)`, 'output');
    }
}

function queryCoherence() {
    const order = typeof computeOrderParameter === 'function' ? computeOrderParameter() : {};
    consoleLog(`=== COHERENCE METRICS ===`, 'info');
    consoleLog(`  œà (Coherence): ${(order.coherence || 0).toFixed(4)}`, 'output');
    consoleLog(`  Mean Field: ${(order.meanField || 0).toFixed(4)}`, 'output');
    consoleLog(`  Variance: ${(order.variance || 0).toFixed(4)}`, 'output');
}

function queryMemory() {
    const mem = typeof epistemicMemory !== 'undefined' ? epistemicMemory : [];
    consoleLog(`=== EPISTEMIC MEMORY (${mem.length} episodes) ===`, 'info');
    if (mem.length === 0) {
        consoleLog('  No crisis episodes recorded yet', 'output');
    } else {
        mem.slice(-5).forEach((ep, i) => {
            consoleLog(`  ${i + 1}. Mode: ${ep.mode} | Cycles: ${ep.cycles} | Success: ${ep.success ? 'YES' : 'NO'}`, 'output');
        });
    }
}

function queryOracle() {
    const oracleList = typeof oracles !== 'undefined' ? oracles : [];
    consoleLog(`=== ORACLE STATUS ===`, 'info');
    consoleLog(`  Active Oracles: ${oracleList.length}`, 'output');
    if (typeof oracleDisagreement !== 'undefined') {
        consoleLog(`  Disagreement Level: ${oracleDisagreement.toFixed(3)}`, 'output');
    }
    if (typeof totalOracleDrift !== 'undefined') {
        consoleLog(`  Total Drift: ${totalOracleDrift.toFixed(4)}`, 'output');
    }
    oracleList.forEach((o, i) => {
        consoleLog(`  Oracle ${i + 1}: truth=${o.truth.toFixed(2)}, drift=${(o.driftDirection || 0).toFixed(3)}`, 'output');
    });
}

function queryArms() {
    const armList = typeof arms !== 'undefined' ? arms : [];
    consoleLog(`=== ARM STATUS (${armList.length} arms) ===`, 'info');
    armList.forEach((arm, i) => {
        const healthy = arm.drones.filter(id => !drones[id]?.isFaulty).length;
        const total = arm.drones.length;
        consoleLog(`  Arm ${i}: ${healthy}/${total} healthy | Ganglion: ${arm.ganglionId}`, 'output');
    });
}

function handleInject(args) {
    const type = args[0];
    const param = args[1];

    switch (type) {
        case 'fault':
            let pct = parseInt(param) || 10;
            if (param && param.includes('%')) pct = parseInt(param);
            const count = Math.floor(drones.length * pct / 100);
            let injected = 0;
            const healthy = drones.filter(d => !d.isFaulty);
            for (let i = 0; i < count && i < healthy.length; i++) {
                const target = healthy[Math.floor(Math.random() * healthy.length)];
                if (target && !target.isFaulty) {
                    injectFault(target);
                    injected++;
                }
            }
            consoleLog(`Injected ${injected} faults (${pct}% of swarm)`, 'success');
            break;
        case 'storm':
            // Increase noise temporarily
            if (typeof STORM_INTENSITY !== 'undefined') {
                consoleLog('Storm injection triggered - increased environmental noise', 'success');
            } else {
                consoleLog('Storm system not available', 'warning');
            }
            break;
        case 'blackout':
            consoleLog('Communication blackout simulated', 'success');
            break;
        default:
            consoleLog('Usage: inject <fault|storm|blackout> [params]', 'warning');
    }
}

function handleSet(args) {
    const target = args[0];
    const value = args.slice(1).join(' ');

    switch (target) {
        case 'waypoint':
            const coords = value.split(',').map(s => parseFloat(s.trim()));
            if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
                if (typeof base !== 'undefined') {
                    base.x = coords[0];
                    base.y = coords[1];
                    consoleLog(`Waypoint set to (${coords[0]}, ${coords[1]})`, 'success');
                }
            } else {
                consoleLog('Usage: set waypoint x,y (e.g., set waypoint 400,300)', 'warning');
            }
            break;
        case 'mode':
            const mode = value.toUpperCase();
            if (['DEM', 'EPI', 'SEN', 'EMG'].includes(mode)) {
                if (typeof transitionCEGMode === 'function') {
                    transitionCEGMode(mode, 'Manual override via console');
                    consoleLog(`CEG mode forced to ${mode}`, 'success');
                }
            } else {
                consoleLog('Usage: set mode <dem|epi|sen|emg>', 'warning');
            }
            break;
        case 'speed':
            const speed = parseInt(value);
            if (speed >= 10 && speed <= 500) {
                document.getElementById('speed').value = speed;
                consoleLog(`Simulation speed set to ${speed}ms`, 'success');
            } else {
                consoleLog('Usage: set speed <10-500>', 'warning');
            }
            break;
        case 'faultrate':
            const rate = parseInt(value);
            if (rate >= 0 && rate <= 20) {
                document.getElementById('fault-rate').value = rate;
                consoleLog(`Fault rate set to ${rate}%`, 'success');
            } else {
                consoleLog('Usage: set faultrate <0-20>', 'warning');
            }
            break;
        default:
            consoleLog('Usage: set <waypoint|mode|speed|faultrate> <value>', 'warning');
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//                    MISSION SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let activeMission = null;
let missionResources = [];
let missionWaypoints = [];
let missionProgress = { collected: 0, total: 0, waypointIndex: 0 };
const RESOURCE_COLLECT_RANGE = 1.5;
const WAYPOINT_REACH_RANGE = 2.0;

function handleMission(args) {
    const mission = args[0];
    const param = args[1];

    switch (mission) {
        case 'forage':
            startForageMission(parseInt(param) || 5);
            break;
        case 'patrol':
            startPatrolMission(parseInt(param) || 4);
            break;
        case 'converge':
            startConvergeMission();
            break;
        case 'disperse':
            startDisperseMission();
            break;
        case 'escort':
            startEscortMission();
            break;
        case 'abort':
            abortMission();
            break;
        case 'status':
            showMissionStatus();
            break;
        default:
            consoleLog('Usage: mission <forage|patrol|converge|disperse|escort|abort|status> [param]', 'warning');
            consoleLog('  forage [n] - Collect n resources (default 5)', 'output');
            consoleLog('  patrol [n] - Patrol n waypoints (default 4)', 'output');
            consoleLog('  converge   - All drones move to center', 'output');
            consoleLog('  disperse   - Spread out from center', 'output');
            consoleLog('  escort     - Protect the base', 'output');
            consoleLog('  abort      - Cancel active mission', 'output');
            consoleLog('  status     - Show mission progress', 'output');
    }
}

function startForageMission(resourceCount) {
    if (activeMission) {
        consoleLog(`Cannot start: Mission '${activeMission.type}' already active. Use 'mission abort' first.`, 'warning');
        return;
    }

    // Spawn resources at random positions
    missionResources = [];
    const canvas = document.getElementById('canvas');
    const w = canvas ? canvas.width : 800;
    const h = canvas ? canvas.height : 600;

    for (let i = 0; i < resourceCount; i++) {
        missionResources.push({
            id: i,
            x: 50 + Math.random() * (w - 100),
            y: 50 + Math.random() * (h - 100),
            collected: false,
            value: 1
        });
    }

    activeMission = {
        type: 'forage',
        startCycle: typeof cycle !== 'undefined' ? cycle : 0,
        startTime: Date.now()
    };
    missionProgress = { collected: 0, total: resourceCount, waypointIndex: 0 };

    consoleLog(`FORAGE MISSION STARTED: Collect ${resourceCount} resources`, 'success');
    triggerAlert('MISSION_START', `Forage mission: ${resourceCount} resources spawned`, 'INFO');
}

function startPatrolMission(waypointCount) {
    if (activeMission) {
        consoleLog(`Cannot start: Mission '${activeMission.type}' already active. Use 'mission abort' first.`, 'warning');
        return;
    }

    // Create patrol waypoints in a circuit
    missionWaypoints = [];
    const canvas = document.getElementById('canvas');
    const w = canvas ? canvas.width : 800;
    const h = canvas ? canvas.height : 600;
    const cx = w / 2, cy = h / 2;
    const radius = Math.min(w, h) * 0.35;

    for (let i = 0; i < waypointCount; i++) {
        const angle = (i / waypointCount) * Math.PI * 2;
        missionWaypoints.push({
            id: i,
            x: cx + Math.cos(angle) * radius,
            y: cy + Math.sin(angle) * radius,
            visited: false
        });
    }

    activeMission = {
        type: 'patrol',
        startCycle: typeof cycle !== 'undefined' ? cycle : 0,
        startTime: Date.now(),
        loops: 0,
        targetLoops: 3
    };
    missionProgress = { collected: 0, total: waypointCount, waypointIndex: 0 };

    // Set first waypoint as target
    if (typeof base !== 'undefined' && missionWaypoints.length > 0) {
        base.x = missionWaypoints[0].x;
        base.y = missionWaypoints[0].y;
    }

    consoleLog(`PATROL MISSION STARTED: ${waypointCount} waypoints, 3 loops`, 'success');
    triggerAlert('MISSION_START', `Patrol mission: ${waypointCount} waypoint circuit`, 'INFO');
}

function startConvergeMission() {
    if (activeMission) {
        consoleLog(`Cannot start: Mission '${activeMission.type}' already active. Use 'mission abort' first.`, 'warning');
        return;
    }

    const canvas = document.getElementById('canvas');
    const cx = (canvas ? canvas.width : 800) / 2;
    const cy = (canvas ? canvas.height : 600) / 2;

    if (typeof base !== 'undefined') {
        base.x = cx;
        base.y = cy;
    }

    activeMission = {
        type: 'converge',
        startCycle: typeof cycle !== 'undefined' ? cycle : 0,
        startTime: Date.now(),
        targetX: cx,
        targetY: cy
    };

    consoleLog(`CONVERGE MISSION: Swarm moving to center (${cx.toFixed(0)}, ${cy.toFixed(0)})`, 'success');
    triggerAlert('MISSION_START', 'Converge mission active', 'INFO');
}

function startDisperseMission() {
    if (activeMission) {
        consoleLog(`Cannot start: Mission '${activeMission.type}' already active. Use 'mission abort' first.`, 'warning');
        return;
    }

    activeMission = {
        type: 'disperse',
        startCycle: typeof cycle !== 'undefined' ? cycle : 0,
        startTime: Date.now()
    };

    // Temporarily increase noise to cause dispersal
    if (typeof drones !== 'undefined') {
        drones.forEach(d => {
            d.disperseAngle = Math.random() * Math.PI * 2;
        });
    }

    consoleLog('DISPERSE MISSION: Swarm spreading outward', 'success');
    triggerAlert('MISSION_START', 'Disperse mission active', 'INFO');
}

function startEscortMission() {
    if (activeMission) {
        consoleLog(`Cannot start: Mission '${activeMission.type}' already active. Use 'mission abort' first.`, 'warning');
        return;
    }

    activeMission = {
        type: 'escort',
        startCycle: typeof cycle !== 'undefined' ? cycle : 0,
        startTime: Date.now()
    };

    consoleLog('ESCORT MISSION: Protecting base position', 'success');
    triggerAlert('MISSION_START', 'Escort/protect mission active', 'INFO');
}

function abortMission() {
    if (!activeMission) {
        consoleLog('No active mission to abort', 'warning');
        return;
    }

    const missionType = activeMission.type;
    const duration = Date.now() - activeMission.startTime;

    activeMission = null;
    missionResources = [];
    missionWaypoints = [];

    consoleLog(`MISSION ABORTED: ${missionType} (ran ${(duration / 1000).toFixed(1)}s)`, 'warning');
    triggerAlert('MISSION_ABORT', `${missionType} mission aborted`, 'WARNING');
}

function showMissionStatus() {
    if (!activeMission) {
        consoleLog('No active mission', 'info');
        consoleLog('Use "mission <type>" to start a mission', 'output');
        return;
    }

    const duration = ((Date.now() - activeMission.startTime) / 1000).toFixed(1);
    const cycles = (typeof cycle !== 'undefined' ? cycle : 0) - activeMission.startCycle;

    consoleLog(`=== MISSION STATUS: ${activeMission.type.toUpperCase()} ===`, 'info');
    consoleLog(`  Duration: ${duration}s (${cycles} cycles)`, 'output');

    if (activeMission.type === 'forage') {
        consoleLog(`  Collected: ${missionProgress.collected}/${missionProgress.total}`, 'output');
        const remaining = missionResources.filter(r => !r.collected).length;
        consoleLog(`  Remaining: ${remaining} resources`, 'output');
    } else if (activeMission.type === 'patrol') {
        consoleLog(`  Waypoint: ${missionProgress.waypointIndex + 1}/${missionWaypoints.length}`, 'output');
        consoleLog(`  Loops: ${activeMission.loops}/${activeMission.targetLoops}`, 'output');
    }
}

// Mission update loop (called from render) - throttled for performance
let lastMissionUpdate = 0;
const MISSION_UPDATE_INTERVAL = 200; // Update mission logic every 200ms

function updateMission() {
    if (!activeMission) return;

    // Throttle mission updates to prevent performance issues
    const now = Date.now();
    if (now - lastMissionUpdate < MISSION_UPDATE_INTERVAL) return;
    lastMissionUpdate = now;

    try {

    if (activeMission.type === 'forage') {
        updateForageMission();
    } else if (activeMission.type === 'patrol') {
        updatePatrolMission();
    } else if (activeMission.type === 'converge') {
        updateConvergeMission();
    } else if (activeMission.type === 'disperse') {
        updateDisperseMission();
    }
    } catch (e) {
        // Silently ignore mission update errors
    }
}

function updateForageMission() {
    if (typeof drones === 'undefined') return;

    // Check if any drone is near an uncollected resource
    missionResources.forEach(resource => {
        if (resource.collected) return;

        drones.forEach(drone => {
            if (drone.isFaulty) return;
            const dx = drone.x - resource.x;
            const dy = drone.y - resource.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < RESOURCE_COLLECT_RANGE) {
                resource.collected = true;
                missionProgress.collected++;
                consoleLog(`Resource ${resource.id + 1} collected! (${missionProgress.collected}/${missionProgress.total})`, 'success');

                // Check mission complete
                if (missionProgress.collected >= missionProgress.total) {
                    completeMission();
                }
            }
        });
    });

    // Guide swarm toward nearest uncollected resource
    const uncollected = missionResources.filter(r => !r.collected);
    if (uncollected.length > 0 && typeof base !== 'undefined') {
        // Find closest to current base position
        let closest = uncollected[0];
        let closestDist = Infinity;
        uncollected.forEach(r => {
            const d = Math.sqrt((r.x - base.x) ** 2 + (r.y - base.y) ** 2);
            if (d < closestDist) {
                closestDist = d;
                closest = r;
            }
        });
        base.x = closest.x;
        base.y = closest.y;
    }
}

function updatePatrolMission() {
    if (typeof base === 'undefined' || missionWaypoints.length === 0) return;

    const currentWaypoint = missionWaypoints[missionProgress.waypointIndex];
    const dx = base.x - currentWaypoint.x;
    const dy = base.y - currentWaypoint.y;

    // Check if swarm reached waypoint (using average drone position would be better)
    if (typeof drones !== 'undefined') {
        let avgX = 0, avgY = 0, count = 0;
        drones.forEach(d => {
            if (!d.isFaulty) {
                avgX += d.x;
                avgY += d.y;
                count++;
            }
        });
        if (count > 0) {
            avgX /= count;
            avgY /= count;
            const distToWaypoint = Math.sqrt((avgX - currentWaypoint.x) ** 2 + (avgY - currentWaypoint.y) ** 2);

            if (distToWaypoint < WAYPOINT_REACH_RANGE * 10) {
                // Reached waypoint, move to next
                currentWaypoint.visited = true;
                missionProgress.waypointIndex = (missionProgress.waypointIndex + 1) % missionWaypoints.length;

                if (missionProgress.waypointIndex === 0) {
                    activeMission.loops++;
                    consoleLog(`Patrol loop ${activeMission.loops}/${activeMission.targetLoops} complete`, 'info');

                    if (activeMission.loops >= activeMission.targetLoops) {
                        completeMission();
                        return;
                    }
                    // Reset visited flags for next loop
                    missionWaypoints.forEach(w => w.visited = false);
                }

                // Set next waypoint as target
                const nextWaypoint = missionWaypoints[missionProgress.waypointIndex];
                base.x = nextWaypoint.x;
                base.y = nextWaypoint.y;
                consoleLog(`Moving to waypoint ${missionProgress.waypointIndex + 1}`, 'output');
            }
        }
    }
}

function updateConvergeMission() {
    if (typeof drones === 'undefined') return;

    // Check if most drones have converged
    let convergedCount = 0;
    const targetX = activeMission.targetX;
    const targetY = activeMission.targetY;

    drones.forEach(d => {
        if (d.isFaulty) return;
        const dist = Math.sqrt((d.x - targetX) ** 2 + (d.y - targetY) ** 2);
        if (dist < 5) convergedCount++;
    });

    const healthyCount = drones.filter(d => !d.isFaulty).length;
    if (convergedCount >= healthyCount * 0.8) {
        completeMission();
    }
}

function updateDisperseMission() {
    // Disperse runs for a fixed duration then completes
    const elapsed = Date.now() - activeMission.startTime;
    if (elapsed > 10000) { // 10 seconds
        completeMission();
    }
}

function completeMission() {
    if (!activeMission) return;

    const missionType = activeMission.type;
    const duration = ((Date.now() - activeMission.startTime) / 1000).toFixed(1);
    const cycles = (typeof cycle !== 'undefined' ? cycle : 0) - activeMission.startCycle;

    consoleLog(`MISSION COMPLETE: ${missionType.toUpperCase()}`, 'success');
    consoleLog(`  Duration: ${duration}s (${cycles} cycles)`, 'output');

    if (missionType === 'forage') {
        consoleLog(`  Collected: ${missionProgress.collected} resources`, 'output');
    } else if (missionType === 'patrol') {
        consoleLog(`  Loops completed: ${activeMission.loops}`, 'output');
    }

    triggerAlert('MISSION_COMPLETE', `${missionType} mission completed in ${duration}s`, 'SUCCESS', {
        type: missionType,
        duration: parseFloat(duration),
        cycles
    });

    activeMission = null;
    missionResources = [];
    missionWaypoints = [];
}

// Update console status display (throttled)
let lastConsoleUpdate = 0;
const CONSOLE_UPDATE_INTERVAL = 500; // Update every 500ms max

function updateConsoleStatus() {
    const now = Date.now();
    if (now - lastConsoleUpdate < CONSOLE_UPDATE_INTERVAL) return;
    lastConsoleUpdate = now;

    try {
        const cycleEl = document.getElementById('console-cycle');
        const modeEl = document.getElementById('console-ceg-mode');
        const psiEl = document.getElementById('console-psi');

        if (cycleEl && typeof cycle !== 'undefined') cycleEl.textContent = cycle;
        if (modeEl && typeof cegMode !== 'undefined') {
            modeEl.textContent = cegMode;
            modeEl.className = `status-item ceg-mode ${cegMode.toLowerCase()}`;
        }
        // Use cached psi from header instead of recomputing
        if (psiEl) {
            const headerPsi = document.getElementById('psi-val');
            if (headerPsi) psiEl.textContent = headerPsi.textContent;
        }
    } catch (e) {
        // Silently ignore errors during status update
    }
}

// Hook into render loop safely
try {
    const originalRender = typeof render === 'function' ? render : null;
    if (originalRender) {
        render = function() {
            try {
                originalRender();
            } catch (e) {
                // Original render failed
            }
            try { updateConsoleStatus(); } catch (e) {}
            try { checkAlertConditions(); } catch (e) {}
            try { updateMission(); } catch (e) {}
            try { renderMissionOverlay(); } catch (e) {}
        };
    }
} catch (e) {
    // Render hook failed, console status won't auto-update
}

// Render mission resources and waypoints on canvas
function renderMissionOverlay() {
    if (!activeMission) return;

    try {
        const canvas = document.getElementById('canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

    // Render resources for forage mission
    if (activeMission.type === 'forage') {
        missionResources.forEach(resource => {
            if (resource.collected) return;
            ctx.save();
            ctx.fillStyle = '#fbbf24';
            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(resource.x, resource.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            // Diamond shape
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(resource.x, resource.y - 4);
            ctx.lineTo(resource.x + 3, resource.y);
            ctx.lineTo(resource.x, resource.y + 4);
            ctx.lineTo(resource.x - 3, resource.y);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        });
    }

    // Render waypoints for patrol mission
    if (activeMission.type === 'patrol') {
        // Draw lines between waypoints
        ctx.save();
        ctx.strokeStyle = 'rgba(34, 211, 238, 0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        missionWaypoints.forEach((wp, i) => {
            if (i === 0) ctx.moveTo(wp.x, wp.y);
            else ctx.lineTo(wp.x, wp.y);
        });
        if (missionWaypoints.length > 0) {
            ctx.lineTo(missionWaypoints[0].x, missionWaypoints[0].y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        // Draw waypoint markers
        missionWaypoints.forEach((wp, i) => {
            ctx.save();
            const isCurrent = i === missionProgress.waypointIndex;
            ctx.fillStyle = isCurrent ? '#22d3ee' : (wp.visited ? '#4ade80' : '#666');
            ctx.strokeStyle = isCurrent ? '#fff' : '#333';
            ctx.lineWidth = isCurrent ? 3 : 1;
            ctx.beginPath();
            ctx.arc(wp.x, wp.y, isCurrent ? 12 : 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            // Number
            ctx.fillStyle = '#000';
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(i + 1, wp.x, wp.y);
            ctx.restore();
        });
    }

    // Render converge target
    if (activeMission.type === 'converge') {
        ctx.save();
        ctx.strokeStyle = '#4ade80';
        ctx.lineWidth = 2;
        const pulse = Math.sin(Date.now() / 200) * 5 + 20;
        ctx.beginPath();
        ctx.arc(activeMission.targetX, activeMission.targetY, pulse, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(activeMission.targetX, activeMission.targetY, pulse * 0.6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
    } catch (e) {
        // Silently ignore render overlay errors
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//                    ALERT ENGINE (Outbound Notifications)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const ALERT_LEVELS = {
    CRITICAL: { priority: 4, color: '#ef4444', icon: 'üî¥', sound: true },
    WARNING:  { priority: 3, color: '#fbbf24', icon: 'üü†', sound: false },
    INFO:     { priority: 2, color: '#8b5cf6', icon: 'üü£', sound: false },
    SUCCESS:  { priority: 1, color: '#4ade80', icon: 'üü¢', sound: false }
};

// Alert configuration
let alertConfig = {
    enabled: true,
    minLevel: 'INFO',           // Minimum level to show
    coherenceThreshold: 0.3,    // Alert if œà drops below
    faultThreshold: 0.25,       // Alert if fault ratio exceeds
    modeChangeAlert: true,      // Alert on CEG mode changes
    missionCompleteAlert: true, // Alert on mission completion
    webhookUrl: null,           // External webhook URL
    telegramBot: null,          // Telegram bot token
    telegramChat: null          // Telegram chat ID
};

// Alert history
let alertHistory = [];
const MAX_ALERT_HISTORY = 100;
let lastAlertCheck = 0;
const ALERT_CHECK_INTERVAL = 1000;
let lastCoherenceAlert = 0;
let lastModeChange = null;

// Trigger an alert
function triggerAlert(type, message, level = 'INFO', data = {}) {
    if (!alertConfig.enabled) return;

    const alertLevel = ALERT_LEVELS[level] || ALERT_LEVELS.INFO;
    const minPriority = ALERT_LEVELS[alertConfig.minLevel]?.priority || 0;

    if (alertLevel.priority < minPriority) return;

    const alert = {
        id: Date.now(),
        type,
        message,
        level,
        timestamp: new Date().toISOString(),
        cycle: typeof cycle !== 'undefined' ? cycle : 0,
        data
    };

    // Add to history
    alertHistory.unshift(alert);
    if (alertHistory.length > MAX_ALERT_HISTORY) alertHistory.pop();

    // Log to console
    const logType = level === 'CRITICAL' ? 'error' :
                    level === 'WARNING' ? 'warning' :
                    level === 'SUCCESS' ? 'success' : 'info';
    consoleLog(`${alertLevel.icon} [${type}] ${message}`, logType);

    // Show visual notification
    showAlertNotification(alert);

    // Send to external services
    sendExternalAlert(alert);

    return alert;
}

// Visual notification popup
function showAlertNotification(alert) {
    const level = ALERT_LEVELS[alert.level];

    // Create notification element
    let container = document.getElementById('alert-notifications');
    if (!container) {
        container = document.createElement('div');
        container.id = 'alert-notifications';
        container.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 350px;
        `;
        document.body.appendChild(container);
    }

    const notification = document.createElement('div');
    notification.style.cssText = `
        background: rgba(10, 5, 16, 0.95);
        border: 2px solid ${level.color};
        border-radius: 6px;
        padding: 10px 14px;
        font-family: 'Consolas', monospace;
        font-size: 0.45rem;
        color: ${level.color};
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        animation: slideIn 0.3s ease-out;
        cursor: pointer;
    `;
    notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
            <span style="font-size: 0.6rem;">${level.icon}</span>
            <span style="font-weight: bold; text-transform: uppercase;">${alert.type}</span>
            <span style="color: #666; margin-left: auto; font-size: 0.35rem;">Cycle ${alert.cycle}</span>
        </div>
        <div style="color: #ccc;">${alert.message}</div>
    `;
    notification.onclick = () => notification.remove();

    container.appendChild(notification);

    // Auto-remove after delay (longer for critical)
    const delay = alert.level === 'CRITICAL' ? 10000 : 5000;
    setTimeout(() => {
        if (notification.parentNode) {
            notification.style.animation = 'slideOut 0.3s ease-in';
            setTimeout(() => notification.remove(), 300);
        }
    }, delay);
}

// Send to external services (webhook, Telegram)
function sendExternalAlert(alert) {
    // Webhook
    if (alertConfig.webhookUrl) {
        try {
            fetch(alertConfig.webhookUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(alert)
            }).catch(() => {});
        } catch (e) {}
    }

    // Telegram (if configured)
    if (alertConfig.telegramBot && alertConfig.telegramChat) {
        const level = ALERT_LEVELS[alert.level];
        const text = `${level.icon} *AION MARS*\n*${alert.type}*\n${alert.message}\n_Cycle: ${alert.cycle}_`;
        try {
            fetch(`https://api.telegram.org/bot${alertConfig.telegramBot}/sendMessage`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: alertConfig.telegramChat,
                    text: text,
                    parse_mode: 'Markdown'
                })
            }).catch(() => {});
        } catch (e) {}
    }
}

// Check for alert conditions (called periodically)
function checkAlertConditions() {
    const now = Date.now();
    if (now - lastAlertCheck < ALERT_CHECK_INTERVAL) return;
    lastAlertCheck = now;

    try {
        // Check coherence
        const psiEl = document.getElementById('psi-val');
        if (psiEl) {
            const psi = parseFloat(psiEl.textContent);
            if (psi < alertConfig.coherenceThreshold && now - lastCoherenceAlert > 10000) {
                triggerAlert('LOW_COHERENCE', `Coherence dropped to ${psi.toFixed(3)} (threshold: ${alertConfig.coherenceThreshold})`, 'CRITICAL', { coherence: psi });
                lastCoherenceAlert = now;
            }
        }

        // Check CEG mode changes
        if (alertConfig.modeChangeAlert && typeof cegMode !== 'undefined') {
            if (lastModeChange !== null && lastModeChange !== cegMode) {
                const level = cegMode === 'EMG' ? 'CRITICAL' : cegMode === 'SEN' ? 'WARNING' : 'INFO';
                triggerAlert('CEG_MODE_CHANGE', `Governance mode changed: ${lastModeChange} ‚Üí ${cegMode}`, level, { from: lastModeChange, to: cegMode });
            }
            lastModeChange = cegMode;
        }

        // Check fault ratio
        if (typeof faults !== 'undefined' && typeof drones !== 'undefined') {
            const faultRatio = faults.length / drones.length;
            if (faultRatio > alertConfig.faultThreshold) {
                triggerAlert('HIGH_FAULTS', `Fault ratio ${(faultRatio * 100).toFixed(1)}% exceeds threshold`, 'WARNING', { faultRatio });
            }
        }
    } catch (e) {
        // Silently ignore check errors
    }
}

// Handle alerts command
function handleAlerts(args) {
    const subcmd = args[0];

    switch (subcmd) {
        case 'on':
            alertConfig.enabled = true;
            consoleLog('Alerts enabled', 'success');
            break;
        case 'off':
            alertConfig.enabled = false;
            consoleLog('Alerts disabled', 'success');
            break;
        case 'level':
            const level = (args[1] || '').toUpperCase();
            if (ALERT_LEVELS[level]) {
                alertConfig.minLevel = level;
                consoleLog(`Alert minimum level set to ${level}`, 'success');
            } else {
                consoleLog('Usage: alerts level <CRITICAL|WARNING|INFO|SUCCESS>', 'warning');
            }
            break;
        case 'threshold':
            const type = args[1];
            const val = parseFloat(args[2]);
            if (type === 'coherence' && !isNaN(val)) {
                alertConfig.coherenceThreshold = val;
                consoleLog(`Coherence alert threshold set to ${val}`, 'success');
            } else if (type === 'fault' && !isNaN(val)) {
                alertConfig.faultThreshold = val;
                consoleLog(`Fault alert threshold set to ${val}`, 'success');
            } else {
                consoleLog('Usage: alerts threshold <coherence|fault> <value>', 'warning');
            }
            break;
        case 'webhook':
            alertConfig.webhookUrl = args[1] || null;
            consoleLog(args[1] ? `Webhook URL set` : 'Webhook disabled', 'success');
            break;
        case 'telegram':
            if (args[1] && args[2]) {
                alertConfig.telegramBot = args[1];
                alertConfig.telegramChat = args[2];
                consoleLog('Telegram alerts configured', 'success');
            } else {
                consoleLog('Usage: alerts telegram <bot_token> <chat_id>', 'warning');
            }
            break;
        case 'history':
            consoleLog(`=== ALERT HISTORY (last 10) ===`, 'info');
            alertHistory.slice(0, 10).forEach(a => {
                consoleLog(`  [${a.level}] ${a.type}: ${a.message}`, 'output');
            });
            break;
        case 'test':
            triggerAlert('TEST', 'This is a test alert', 'INFO');
            break;
        case 'status':
        default:
            consoleLog(`=== ALERT CONFIGURATION ===`, 'info');
            consoleLog(`  Enabled: ${alertConfig.enabled}`, 'output');
            consoleLog(`  Min Level: ${alertConfig.minLevel}`, 'output');
            consoleLog(`  Coherence Threshold: ${alertConfig.coherenceThreshold}`, 'output');
            consoleLog(`  Fault Threshold: ${alertConfig.faultThreshold}`, 'output');
            consoleLog(`  Webhook: ${alertConfig.webhookUrl ? 'Configured' : 'Not set'}`, 'output');
            consoleLog(`  Telegram: ${alertConfig.telegramBot ? 'Configured' : 'Not set'}`, 'output');
            consoleLog(`  History: ${alertHistory.length} alerts`, 'output');
            break;
    }
}

// Add CSS animation for notifications
const alertStyle = document.createElement('style');
alertStyle.textContent = `
    @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
    }
`;
document.head.appendChild(alertStyle);

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//                    TELEGRAM REMOTE COMMAND BRIDGE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let telegramBridge = {
    enabled: false,
    botToken: null,
    chatId: null,
    lastUpdateId: 0,
    pollInterval: null,
    pollRate: 3000,  // Poll every 3 seconds
    authorizedUsers: []  // List of authorized user IDs
};

// Start Telegram polling
function startTelegramBridge(botToken, chatId) {
    if (!botToken || !chatId) {
        consoleLog('Usage: telegram start <bot_token> <chat_id>', 'warning');
        return;
    }

    telegramBridge.botToken = botToken;
    telegramBridge.chatId = chatId;
    telegramBridge.enabled = true;
    telegramBridge.authorizedUsers.push(parseInt(chatId));

    // Start polling for messages
    telegramBridge.pollInterval = setInterval(pollTelegramUpdates, telegramBridge.pollRate);

    consoleLog('Telegram bridge started - listening for remote commands', 'success');
    sendTelegramMessage('ü§ñ AION MARS connected! Send /help for commands.');
    triggerAlert('TELEGRAM_CONNECTED', 'Remote command bridge active', 'SUCCESS');
}

// Stop Telegram polling
function stopTelegramBridge() {
    telegramBridge.enabled = false;
    if (telegramBridge.pollInterval) {
        clearInterval(telegramBridge.pollInterval);
        telegramBridge.pollInterval = null;
    }
    consoleLog('Telegram bridge stopped', 'success');
}

// Poll for new messages
async function pollTelegramUpdates() {
    if (!telegramBridge.enabled || !telegramBridge.botToken) return;

    try {
        const url = `https://api.telegram.org/bot${telegramBridge.botToken}/getUpdates?offset=${telegramBridge.lastUpdateId + 1}&timeout=1`;
        const response = await fetch(url);
        const data = await response.json();

        if (data.ok && data.result && data.result.length > 0) {
            data.result.forEach(update => {
                telegramBridge.lastUpdateId = update.update_id;
                if (update.message && update.message.text) {
                    handleTelegramCommand(update.message);
                }
            });
        }
    } catch (e) {
        // Silently ignore polling errors
    }
}

// Handle incoming Telegram command
function handleTelegramCommand(message) {
    const chatId = message.chat.id;
    const userId = message.from.id;
    const text = message.text.trim();
    const username = message.from.username || message.from.first_name || 'Unknown';

    consoleLog(`[Telegram] ${username}: ${text}`, 'info');

    // Check authorization
    if (telegramBridge.authorizedUsers.length > 0 &&
        !telegramBridge.authorizedUsers.includes(userId)) {
        sendTelegramMessage('‚õî Unauthorized. Your user ID is not in the authorized list.', chatId);
        return;
    }

    // Handle Telegram-style commands (with /)
    let cmd = text;
    if (cmd.startsWith('/')) {
        cmd = cmd.substring(1);
    }

    // Process command
    const response = processTelegramCommand(cmd);
    sendTelegramMessage(response, chatId);
}

// Process command and return response
function processTelegramCommand(cmdString) {
    const parts = cmdString.toLowerCase().split(/\s+/);
    const cmd = parts[0];
    const args = parts.slice(1);

    try {
        switch (cmd) {
            case 'help':
                return `ü§ñ *AION MARS Commands*

*Status*
/status - Swarm overview
/ceg - Governance state
/mission - Mission status

*Control*
/start - Start simulation
/stop - Stop simulation
/pulse - Trigger recalibration

*Missions*
/forage [n] - Start forage mission
/patrol [n] - Start patrol mission
/converge - Converge to center
/abort - Abort mission

*Inject*
/fault [%] - Inject faults
/mode [dem|epi|sen|emg] - Set CEG mode

*Alerts*
/alerts - Alert status
/mute - Disable alerts
/unmute - Enable alerts`;

            case 'status':
                const psi = document.getElementById('psi-val')?.textContent || '?';
                const faultCount = typeof faults !== 'undefined' ? faults.length : 0;
                const droneCount = typeof drones !== 'undefined' ? drones.length : 0;
                const currentCycle = typeof cycle !== 'undefined' ? cycle : 0;
                const mode = typeof cegMode !== 'undefined' ? cegMode : 'N/A';
                return `üìä *AION Status @ Cycle ${currentCycle}*
üêù Drones: ${droneCount}
‚ö° Faults: ${faultCount}
üåä Coherence: ${psi}
üèõÔ∏è CEG Mode: ${mode}
‚ñ∂Ô∏è Running: ${isRunning ? 'Yes' : 'No'}`;

            case 'ceg':
                const cMode = typeof cegMode !== 'undefined' ? cegMode : 'N/A';
                const cyclesIn = typeof cegCyclesInMode !== 'undefined' ? cegCyclesInMode : 0;
                return `üèõÔ∏è *CEG Governance*
Mode: ${cMode}
Cycles: ${cyclesIn}`;

            case 'mission':
                if (!activeMission) {
                    return 'üìã No active mission\nUse /forage, /patrol, or /converge to start';
                }
                const dur = ((Date.now() - activeMission.startTime) / 1000).toFixed(0);
                let missionInfo = `üìã *Mission: ${activeMission.type.toUpperCase()}*\nDuration: ${dur}s`;
                if (activeMission.type === 'forage') {
                    missionInfo += `\nCollected: ${missionProgress.collected}/${missionProgress.total}`;
                } else if (activeMission.type === 'patrol') {
                    missionInfo += `\nLoop: ${activeMission.loops}/${activeMission.targetLoops}`;
                }
                return missionInfo;

            case 'start':
                startExperiment();
                return '‚ñ∂Ô∏è Simulation started';

            case 'stop':
                stopExperiment();
                return '‚èπÔ∏è Simulation stopped';

            case 'pulse':
                triggerRecalibrationPulse();
                return 'üì° Recalibration pulse triggered';

            case 'forage':
                const forageCount = parseInt(args[0]) || 5;
                startForageMission(forageCount);
                return `üåæ Forage mission started: ${forageCount} resources`;

            case 'patrol':
                const waypointCount = parseInt(args[0]) || 4;
                startPatrolMission(waypointCount);
                return `üöÅ Patrol mission started: ${waypointCount} waypoints`;

            case 'converge':
                startConvergeMission();
                return 'üéØ Converge mission started';

            case 'disperse':
                startDisperseMission();
                return 'üí® Disperse mission started';

            case 'abort':
                abortMission();
                return 'üõë Mission aborted';

            case 'fault':
                const pct = parseInt(args[0]) || 10;
                const count = Math.floor((typeof drones !== 'undefined' ? drones.length : 0) * pct / 100);
                let injected = 0;
                if (typeof drones !== 'undefined' && typeof injectFault === 'function') {
                    const healthy = drones.filter(d => !d.isFaulty);
                    for (let i = 0; i < count && i < healthy.length; i++) {
                        const target = healthy[Math.floor(Math.random() * healthy.length)];
                        if (target && !target.isFaulty) {
                            injectFault(target);
                            injected++;
                        }
                    }
                }
                return `‚ö° Injected ${injected} faults (${pct}%)`;

            case 'mode':
                const newMode = (args[0] || '').toUpperCase();
                if (['DEM', 'EPI', 'SEN', 'EMG'].includes(newMode)) {
                    if (typeof transitionCEGMode === 'function') {
                        transitionCEGMode(newMode, 'Telegram remote command');
                    }
                    return `üèõÔ∏è CEG mode set to ${newMode}`;
                }
                return '‚ö†Ô∏è Usage: /mode <dem|epi|sen|emg>';

            case 'alerts':
                return `üîî *Alert Config*
Enabled: ${alertConfig.enabled}
Level: ${alertConfig.minLevel}
Coherence Threshold: ${alertConfig.coherenceThreshold}
History: ${alertHistory.length} alerts`;

            case 'mute':
                alertConfig.enabled = false;
                return 'üîá Alerts muted';

            case 'unmute':
                alertConfig.enabled = true;
                return 'üîî Alerts enabled';

            default:
                // Try to execute as console command
                executeCommand(cmdString);
                return `‚úÖ Command executed: ${cmdString}`;
        }
    } catch (e) {
        return `‚ùå Error: ${e.message}`;
    }
}

// Send message to Telegram
async function sendTelegramMessage(text, chatId = null) {
    if (!telegramBridge.botToken) return;

    const targetChat = chatId || telegramBridge.chatId;
    if (!targetChat) return;

    try {
        await fetch(`https://api.telegram.org/bot${telegramBridge.botToken}/sendMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: targetChat,
                text: text,
                parse_mode: 'Markdown'
            })
        });
    } catch (e) {
        // Silently ignore send errors
    }
}

// Handle telegram command from console
function handleTelegram(args) {
    const subcmd = args[0];

    switch (subcmd) {
        case 'start':
            startTelegramBridge(args[1], args[2]);
            break;
        case 'stop':
            stopTelegramBridge();
            break;
        case 'send':
            const message = args.slice(1).join(' ');
            sendTelegramMessage(message);
            consoleLog('Message sent to Telegram', 'success');
            break;
        case 'auth':
            const userId = parseInt(args[1]);
            if (userId) {
                telegramBridge.authorizedUsers.push(userId);
                consoleLog(`User ${userId} authorized`, 'success');
            } else {
                consoleLog('Usage: telegram auth <user_id>', 'warning');
            }
            break;
        case 'status':
        default:
            consoleLog(`=== TELEGRAM BRIDGE ===`, 'info');
            consoleLog(`  Enabled: ${telegramBridge.enabled}`, 'output');
            consoleLog(`  Bot Token: ${telegramBridge.botToken ? 'Set' : 'Not set'}`, 'output');
            consoleLog(`  Chat ID: ${telegramBridge.chatId || 'Not set'}`, 'output');
            consoleLog(`  Authorized Users: ${telegramBridge.authorizedUsers.length}`, 'output');
            consoleLog(`  Poll Rate: ${telegramBridge.pollRate}ms`, 'output');
            break;
    }
}

// Add telegram to command list
COMMANDS['telegram'] = { desc: 'Configure Telegram remote control', category: 'META' };
COMMANDS['telegram start'] = { desc: 'Start bridge (telegram start <token> <chat_id>)', category: 'META' };
COMMANDS['telegram stop'] = { desc: 'Stop Telegram bridge', category: 'META' };
COMMANDS['telegram send'] = { desc: 'Send message to Telegram', category: 'META' };

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//                    STRESS TEST MODULE
//                    Rising pressure test to find breaking point
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let stressTest = {
    active: false,
    startCycle: 0,
    startTime: 0,
    currentLevel: 0,           // 0-100 stress level
    rampRate: 0.01,            // Stress increase per cycle (default: reaches 100 in 10k cycles)
    faultRateMultiplier: 1,    // Multiplier for fault injection
    stormMultiplier: 1,        // Multiplier for storm intensity
    noiseMultiplier: 1,        // Multiplier for noise
    coherenceFloor: 0.3,       // Coherence below this = system "broken"
    faultCeiling: 0.6,         // Fault ratio above this = system "broken"
    breakdownCycle: null,      // Cycle when system broke
    breakdownReason: null,     // Why it broke
    log: []                    // Periodic snapshots
};

function startStressTest(rampRate = 0.01) {
    if (typeof cycle === 'undefined') {
        consoleLog('Error: Simulation not initialized', 'error');
        return;
    }

    stressTest = {
        active: true,
        startCycle: cycle,
        startTime: Date.now(),
        currentLevel: 0,
        rampRate: rampRate,
        faultRateMultiplier: 1,
        stormMultiplier: 1,
        noiseMultiplier: 1,
        coherenceFloor: 0.3,
        faultCeiling: 0.6,
        breakdownCycle: null,
        breakdownReason: null,
        log: []
    };

    consoleLog('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó', 'warning');
    consoleLog('‚ïë      STRESS TEST INITIATED                 ‚ïë', 'warning');
    consoleLog('‚ïë      Rising pressure until breakdown       ‚ïë', 'warning');
    consoleLog(`‚ïë      Ramp rate: ${(rampRate * 100).toFixed(2)}% per cycle           ‚ïë`, 'warning');
    consoleLog('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù', 'warning');

    triggerAlert('STRESS_TEST', 'Stress test initiated - rising pressure', 'WARNING', { rampRate });
}

function stopStressTest() {
    if (!stressTest.active) {
        consoleLog('No stress test running', 'warning');
        return;
    }

    const duration = Date.now() - stressTest.startTime;
    const cycles = (typeof cycle !== 'undefined' ? cycle : 0) - stressTest.startCycle;

    consoleLog('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó', 'info');
    consoleLog('‚ïë      STRESS TEST RESULTS                   ‚ïë', 'info');
    consoleLog('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù', 'info');
    consoleLog(`  Duration: ${(duration / 1000).toFixed(1)}s (${cycles} cycles)`, 'output');
    consoleLog(`  Final Stress Level: ${(stressTest.currentLevel * 100).toFixed(1)}%`, 'output');

    if (stressTest.breakdownCycle) {
        consoleLog(`  BREAKDOWN at cycle ${stressTest.breakdownCycle}`, 'error');
        consoleLog(`  Reason: ${stressTest.breakdownReason}`, 'error');
        consoleLog(`  Survived: ${stressTest.breakdownCycle - stressTest.startCycle} cycles under stress`, 'output');
    } else {
        consoleLog('  System survived without breakdown!', 'success');
    }

    stressTest.active = false;
}

function updateStressTest() {
    if (!stressTest.active || stressTest.breakdownCycle) return;

    // Increase stress level
    stressTest.currentLevel = Math.min(1, stressTest.currentLevel + stressTest.rampRate);

    // Apply stress multipliers (exponential scaling for dramatic effect)
    const stressExp = Math.pow(stressTest.currentLevel, 1.5);
    stressTest.faultRateMultiplier = 1 + stressExp * 200;   // Up to 201x fault rate
    stressTest.stormMultiplier = 1 + stressExp * 4;         // Up to 5x storm
    stressTest.noiseMultiplier = 1 + stressExp * 10;        // Up to 11x noise

    // Force inject faults at high stress levels
    if (stressTest.currentLevel > 0.5 && typeof injectFault === 'function') {
        if (Math.random() < stressTest.currentLevel * 0.1) {
            try { injectFault(); } catch(e) {}
        }
    }

    // Check for breakdown
    if (typeof drones !== 'undefined' && typeof computeOrderParameter === 'function') {
        try {
            const order = computeOrderParameter();
            const faultRatio = drones.filter(d => d.isFaulty).length / drones.length;

            if (order.coherence < stressTest.coherenceFloor) {
                stressTest.breakdownCycle = cycle;
                stressTest.breakdownReason = `Coherence collapsed to ${order.coherence.toFixed(3)}`;
                announceBreakdown();
            } else if (faultRatio > stressTest.faultCeiling) {
                stressTest.breakdownCycle = cycle;
                stressTest.breakdownReason = `Fault ratio exceeded ${(faultRatio * 100).toFixed(1)}%`;
                announceBreakdown();
            }

            // Log every 500 cycles
            if ((cycle - stressTest.startCycle) % 500 === 0) {
                stressTest.log.push({
                    cycle,
                    stressLevel: stressTest.currentLevel,
                    coherence: order.coherence,
                    faultRatio,
                    cegMode: typeof cegMode !== 'undefined' ? cegMode : 'N/A'
                });
            }
        } catch (e) {
            // Ignore errors during stress check
        }
    }
}

function announceBreakdown() {
    consoleLog('', 'output');
    consoleLog('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó', 'error');
    consoleLog('‚ïë           SYSTEM BREAKDOWN                 ‚ïë', 'error');
    consoleLog('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù', 'error');
    consoleLog(`  Cycle: ${stressTest.breakdownCycle}`, 'error');
    consoleLog(`  Stress Level: ${(stressTest.currentLevel * 100).toFixed(1)}%`, 'error');
    consoleLog(`  Reason: ${stressTest.breakdownReason}`, 'error');
    consoleLog(`  Survived: ${stressTest.breakdownCycle - stressTest.startCycle} cycles`, 'output');

    triggerAlert('BREAKDOWN', stressTest.breakdownReason, 'CRITICAL', {
        cycle: stressTest.breakdownCycle,
        stressLevel: stressTest.currentLevel,
        survivedCycles: stressTest.breakdownCycle - stressTest.startCycle
    });
}

function getStressMultipliers() {
    if (!stressTest.active) {
        return { fault: 1, storm: 1, noise: 1 };
    }
    return {
        fault: stressTest.faultRateMultiplier,
        storm: stressTest.stormMultiplier,
        noise: stressTest.noiseMultiplier
    };
}

// Hook stress test into render loop
const originalRenderForStress = typeof render === 'function' ? render : null;
if (originalRenderForStress) {
    render = function() {
        originalRenderForStress();
        updateStressTest();
    };
}

// Add stress test commands
COMMANDS['stress'] = { desc: 'Start stress test (stress [ramp_rate])', category: 'CONTROL' };
COMMANDS['stress stop'] = { desc: 'Stop stress test and show results', category: 'CONTROL' };
COMMANDS['stress status'] = { desc: 'Show current stress test status', category: 'CONTROL' };

// Handle stress command in executeCommand
const originalExecuteCommand = executeCommand;
executeCommand = function(cmdString) {
    const parts = cmdString.trim().toLowerCase().split(/\s+/);
    const cmd = parts[0];

    if (cmd === 'stress') {
        const subCmd = parts[1];
        if (subCmd === 'stop') {
            stopStressTest();
        } else if (subCmd === 'status') {
            if (stressTest.active) {
                consoleLog(`=== STRESS TEST STATUS ===`, 'info');
                consoleLog(`  Active: Yes`, 'output');
                consoleLog(`  Level: ${(stressTest.currentLevel * 100).toFixed(1)}%`, 'output');
                consoleLog(`  Cycles: ${cycle - stressTest.startCycle}`, 'output');
                consoleLog(`  Fault Mult: ${stressTest.faultRateMultiplier.toFixed(1)}x`, 'output');
                consoleLog(`  Storm Mult: ${stressTest.stormMultiplier.toFixed(1)}x`, 'output');
            } else {
                consoleLog('No stress test active', 'info');
            }
        } else {
            const rampRate = parseFloat(parts[1]) || 0.01;
            startStressTest(rampRate);
        }
        return;
    }

    originalExecuteCommand(cmdString);
};

// Log version info
console.log('üåÄ Gateway Framework Edition');
console.log(`  Œì = ${GAMMA.toFixed(15)}`);
console.log(`  œÜ √ó Œì = ${(PHI * GAMMA).toFixed(15)} (should be ${(1/6).toFixed(15)})`);
console.log(`  Identity check: ${Math.abs(PHI * GAMMA - 1/6) < 1e-14 ? '‚úì PASS' : '‚úó FAIL'}`);
</script>

</body>
</html>
